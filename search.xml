<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[理解 JVM：Java 内存模型（二）——volatile]]></title>
      <url>%2F2017%2F11%2F11%2Fjava-memory-model-02%2F</url>
      <content type="text"><![CDATA[概述 java 内存模型的核心是围绕着在并发过程中如何处理原子性、可见性、有序性这3个特性来展开的，它们是多线程编程的核心。 原子性（Atomicity）：是指一个操作是不可中断的，即使是多个线程同时执行的情况下，一个操作一旦开始，就不会被其它线程干扰。对于基本类型的读写操作基本都具有原子性的（在32位操作系统中 long 和 double 类型数据的读写不是原子性的，因为它们有64位）。 可见性（Visibility）：是指在多线程环境下，当一个线程修改了某一个共享变量的值，其它线程能够立刻知道这个修改。 有序性（Ordering）：是指程序的执行顺序是按照代码的先后顺序执行的；对于这句话如果在单线程中所有的操作都是有序的，但是在多线程环境下，一个线程的操作相对于另外一个线程的操作是无序的。 关键字 volatile volatile 修饰的变量保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。因为当对普通变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。而volatile修饰的变量，JVM保证了每次读变量都从内存中读，跳过CPU cache这一步。volatile修饰的变量禁止进行指令重排序，所以能在一定程度上保证有序性。只能保证该变量所在的语句还是原来的位置，并不能保证该语句之前或之后的语句是否被打乱。 volatile 的特性 可见性，当一个变量被 volatile 修饰之后，能保证此变量对所有线程的可见性，即当一个线程修改了这个变量的值，新值对其它线程是立即可见的。 一定程度上保证有序性，被 volatile 修饰的变量禁止指令重排序，所以能在一定程度上保证有序性。 对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。 例如： 123456789101112131415161718192021222324252627282930313233343536373839package com.pdh.test;/** * volatile 复合操作测试 * * @author pengdh * @date 2017/11/12 */public class VolatileDemo &#123; // 申明 volatile 变量 private static volatile int i = 0; // 计数 private static final int COUNT = 10; /** * 对 volatile 变量复合运算 */ private static void increase() &#123; i++; &#125; public static void main(String[] args) &#123; // 启动 10 个线程分别对 i 进行 10000 次计算，正常情况结果为 100000 for (int j = 0; j &lt; COUNT; j++) &#123; new Thread(() -&gt; &#123; for (int k = 0; k &lt; 10000; k++) &#123; increase(); &#125; &#125;).start(); &#125; // 等待所有累加线程全部执行结束，这里不同 ide 中线程存活数不一样， // 该示例代码在 idea 中运行，会多出一个 Monitor Ctrl-Break 线程，故条件是 &gt; 2， // 如果在 Eclipse 中条件应为 &gt; 1 while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(i); &#125;&#125; 如上代码正常运行结果应该打印100000，但实际结果基本得不到正确结果。这说明了 volatile 变量的复合运算并不具有原子性，想要得到正确结果，需要对 volatile 变量运算操作加锁或者加上同步块。 12345678910111213141516171819202122232425262728293031323334353637383940package com.pdh.test;/** * volatile 复合操作测试 * * @author pengdh * @date 2017/11/12 */public class VolatileDemo &#123; // 申明 volatile 变量 private static volatile int i = 0; // 计数 private static final int COUNT = 10; /** * 对 volatile 变量复合运算，使用 synchronized 同步 */ private static synchronized void increase() &#123; i++; &#125; public static void main(String[] args) &#123; // 启动 10 个线程分别对 i 进行 10000 次计算，正常情况结果为 100000 for (int j = 0; j &lt; COUNT; j++) &#123; new Thread(() -&gt; &#123; for (int k = 0; k &lt; 10000; k++) &#123; increase(); &#125; &#125;).start(); &#125; // 等待所有累加线程全部执行结束，这里不同 ide 中线程存活数不一样， // 该示例代码在 idea 中运行，会多出一个 Monitor Ctrl-Break 线程，故条件是 &gt; 2， // 如果在 Eclipse 中条件应为 &gt; 1 while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(i); &#125;&#125; volatile 适合场景volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记，如： 1234567891011121314151617181920212223242526272829303132333435363738package com.pdh.test;/** * volatile 复合操作测试 * * @author pengdh * @date 2017/11/12 */public class VolatileDemo &#123; // 申明 volatile 变量 private volatile boolean flag = false; // 计数 private static final int COUNT = 10; /** * 使用 volatile 变量作为线程结束标志 */ private void start() &#123; new Thread(() -&gt; &#123; while (!flag) &#123; System.out.println("Thread is running"); &#125; &#125;).start(); &#125; private void shutdown() &#123; flag = true; System.out.println("Thread is stop"); &#125; public static void main(String[] args) throws InterruptedException &#123; VolatileDemo demo = new VolatileDemo(); demo.start(); Thread.sleep(2000); demo.shutdown(); &#125;&#125; 使用 volatile 的意义在某些情况下，volatile 的同步机制性能要优于锁。 参考文献 深入理解 Java 虚拟机]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[httpclient 调用工具（同时支持 HTTP 和 HTTPS 协议）]]></title>
      <url>%2F2017%2F10%2F28%2Fhttpclient-tools%2F</url>
      <content type="text"><![CDATA[简介 接口调用是作为后端开发人员在编码过程中的日常，而 HTTP 协议可能是现在 Internet 上使用最多、最重要的协议。虽然在 JDK 的 java net包中已经提供了访问 HTTP 协议的基本功能，但是对于大部分应用程序来说，JDK 库本身提供的功能还不够丰富和灵活。HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。随着互联网安全性提高，各个互联网公司将自己站点 HTTPS 化，而在调用 HTTPS 协议接口时需要 SSL 证书认证。一般做法是创建一个SSL连接，接受自签名证书的信任策略，使其通过验证。 下面是一个我日常调用接口时使用的 httpclient 调用工具 引入 jar 包maven 引入 httpclient jar包： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.4.6&lt;/version&gt;&lt;/dependency&gt; HttpClientUtil.javahttpclient 调用工具类，封装一系列静态入口方法，供其它对象调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318package com.pdh.http;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.nio.charset.UnsupportedCharsetException;import java.util.ArrayList;import java.util.Iterator;import java.util.Map;import org.apache.http.Header;import org.apache.http.HttpEntity;import org.apache.http.HttpStatus;import org.apache.http.NameValuePair;import org.apache.http.ParseException;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.methods.HttpRequestBase;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;/** * httpclient 调用工具 * * @author pengdh * @date 2017/10/28 */public class HttpClientUtil &#123; /** * 缺省超时时间 单位：ms */ private static final int TIMEOUT = 60000; /** * 是否重定向标识 */ private static final boolean IS_REDIRECTS = false; private static String EMPTY_STR = ""; /** * 字符集编码格式 */ private static String UTF_8 = "UTF-8"; private HttpClientUtil() &#123; &#125; /** * 发送 get 请求 * * @param url 请求地址 * @return String */ public static String httpGetRequest(String url) &#123; HttpGet httpGet = new HttpGet(url); return execute(httpGet); &#125; /** * 发送 get 请求 * * @param url 请求地址 * @param headers 头信息 * @return String */ public static String httpGetRequestWithHeaders(String url, Map&lt;String, Object&gt; headers) &#123; HttpGet httpGet = new HttpGet(url); for (Map.Entry&lt;String, Object&gt; param : headers.entrySet()) &#123; httpGet.addHeader(param.getKey(), String.valueOf(param.getValue())); &#125; return execute(httpGet); &#125; /** * 发送 get 请求 * * @param url 请求地址 * @param headers 头信息 * @param params 参数 * @return String */ public static String httpGetRequest(String url, Map&lt;String, Object&gt; headers, Map&lt;String, Object&gt; params) &#123; HttpGet httpGet = new HttpGet(createParamUrl(url, params)); for (Map.Entry&lt;String, Object&gt; param : headers.entrySet()) &#123; httpGet.addHeader(param.getKey(), String.valueOf(param.getValue())); &#125; return execute(httpGet); &#125; /** * 发送 get 请求 * * @param url 请求地址 * @return String */ public static String httpGetRequestWithParams(String url, Map&lt;String, Object&gt; params) &#123; HttpGet httpGet = new HttpGet(createParamUrl(url, params)); return execute(httpGet); &#125; /** * 创建带参数的 URL * * @param url 无参URL * @param params 参数 * @return String 带参数URL */ private static String createParamUrl(String url, Map&lt;String, Object&gt; params) &#123; Iterator&lt;String&gt; it = params.keySet().iterator(); StringBuilder sb = new StringBuilder(); boolean isIncludeQuestionMark = url.contains("?"); if (!isIncludeQuestionMark) &#123; sb.append("?"); &#125; while (it.hasNext()) &#123; String key = it.next(); String value = (String) params.get(key); sb.append("&amp;"); sb.append(key); sb.append("="); sb.append(value); &#125; url += sb.toString(); return url; &#125; /** * 发送 post 请求 * * @param url 请求地址 * @return String */ public static String httpPostRequest(String url) &#123; HttpPost httpPost = new HttpPost(url); return execute(httpPost); &#125; /** * 发送 post 请求 * * @param url 地址 * @param params 参数 * @return String */ public static String httpPostRequest(String url, Map&lt;String, Object&gt; params) &#123; HttpPost httpPost = new HttpPost(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); try &#123; httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return execute(httpPost); &#125; /** * 发送 post 请求 * * @param url 地址 * @param headers 头信息 * @param params 参数 * @return String */ public static String httpPostRequest(String url, Map&lt;String, Object&gt; headers, Map&lt;String, Object&gt; params) &#123; HttpPost httpPost = new HttpPost(url); for (Map.Entry&lt;String, Object&gt; headerParam : headers.entrySet()) &#123; httpPost.addHeader(headerParam.getKey(), String.valueOf(headerParam.getValue())); &#125; ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); try &#123; httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return execute(httpPost); &#125; /** * 发送 post 请求 * * @param url 地址 * @param headers 头信息 * @param json json 格式参数 * @return String */ public static String httpPostRequestByJson(String url, Map&lt;String, Object&gt; headers, String json) &#123; HttpPost httpPost = new HttpPost(url); for (Map.Entry&lt;String, Object&gt; headerParam : headers.entrySet()) &#123; httpPost.addHeader(headerParam.getKey(), String.valueOf(headerParam.getValue())); &#125; try &#123; httpPost.setEntity(new StringEntity(json, UTF_8)); &#125; catch (UnsupportedCharsetException e) &#123; e.printStackTrace(); &#125; return execute(httpPost); &#125; /** * 把参数转换为名值对数组 * * @param params 参数 * @return ArrayList&lt;NameValuePair&gt; */ private static ArrayList&lt;NameValuePair&gt; covertParams2NVPS(Map&lt;String, Object&gt; params) &#123; ArrayList&lt;NameValuePair&gt; pairs = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, Object&gt; param : params.entrySet()) &#123; pairs.add(new BasicNameValuePair(param.getKey(), String.valueOf(param.getValue()))); &#125; return pairs; &#125; /** * 执行 HTTP 请求 若重定向返回重定向地址 * * @return String */ private static String execute(HttpRequestBase request) &#123; String result = EMPTY_STR; request.setConfig(createConfig(TIMEOUT, IS_REDIRECTS)); CloseableHttpClient httpClient = getHttpClient(); try &#123; CloseableHttpResponse response = httpClient.execute(request); if (isRedirected(response)) &#123; result = getRedirectedUrl(response); &#125; else &#123; result = getEntityData(response); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 创建HTTP请求配置 * * @param timeout 超时时间 * @param redirectsEnabled 是否开启重定向 * @return RequestConfig */ private static RequestConfig createConfig(int timeout, boolean redirectsEnabled) &#123; return RequestConfig.custom() // 读取数据超时时间（毫秒） .setSocketTimeout(timeout) // 建立连接超时时间（毫秒） .setConnectTimeout(timeout) // 从连接池获取连接的等待时间（毫秒） .setConnectionRequestTimeout(timeout) // 当响应状态码为302时，是否进行重定向 .setRedirectsEnabled(redirectsEnabled) .build(); &#125; /** * 通过连接池获取 httpclient */ private static CloseableHttpClient getHttpClient() &#123; return HttpClients.custom().setConnectionManager( HttpConnectionManager.POOLING_CONNECTION_MANAGER).build(); &#125; /** * 判断发送请求是否重定向跳转过 * * @param response 请求响应 * @return boolean */ private static boolean isRedirected(CloseableHttpResponse response) &#123; int statusCode = response.getStatusLine().getStatusCode(); return statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY; &#125; /** * 获得重定向跳转地址 * * @param response 请求响应 * @return String 重定向地址 */ private static String getRedirectedUrl(CloseableHttpResponse response) &#123; String result = EMPTY_STR; Header[] hs = response.getHeaders("Location"); if (hs.length &gt; 0) &#123; result = hs[0].getValue(); &#125; return result; &#125; /** * 获得响应实体信息 * * @param response 请求响应 * @return String 消息实体信息 */ private static String getEntityData(CloseableHttpResponse response) throws ParseException, IOException &#123; String result = EMPTY_STR; HttpEntity entity = response.getEntity(); if (entity != null) &#123; result = EntityUtils.toString(entity); response.close(); &#125; return result; &#125;&#125; HttpConnectionManager.javahttpClient 连接管理器，支持创建普通连接和使用使用连接池 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.migu.barrage.common.http;import org.apache.http.config.Registry;import org.apache.http.config.RegistryBuilder;import org.apache.http.conn.HttpClientConnectionManager;import org.apache.http.conn.socket.ConnectionSocketFactory;import org.apache.http.conn.socket.PlainConnectionSocketFactory;import org.apache.http.impl.conn.BasicHttpClientConnectionManager;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;/** * httpClient 连接管理器 * * @author pengdh * @date 2017/10/28 */public class HttpConnectionManager &#123; /** * 普通连接管理器 */ public static final HttpClientConnectionManager BASIC_CONNECTION_MANAGER; /** * 连接池管理器 */ public static final HttpClientConnectionManager POOLING_CONNECTION_MANAGER; static &#123; Registry&lt;ConnectionSocketFactory&gt; r = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create() .register("http", PlainConnectionSocketFactory.getSocketFactory()) .register("https", SSLSelfSigned.SSL_CONNECTION_SOCKET_FACTORY).build(); // 普通连接管理器 BASIC_CONNECTION_MANAGER = new BasicHttpClientConnectionManager(r); // 连接池管理器 PoolingHttpClientConnectionManager pooling = new PoolingHttpClientConnectionManager(r); // 设置最大连接数 pooling.setMaxTotal(1000); // 设置每个路由基础上的最大连接数 pooling.setDefaultMaxPerRoute(300); POOLING_CONNECTION_MANAGER = pooling; &#125; private HttpConnectionManager() &#123; &#125; /** * @param max httpClient 最大连接数 */ public static void setMaxTotal(int max) &#123; ((PoolingHttpClientConnectionManager) POOLING_CONNECTION_MANAGER).setMaxTotal(max); &#125; /** * @param max 每个路由基础上的最大连接数 */ public static void setDefaultMaxPerRoute(int max) &#123; ((PoolingHttpClientConnectionManager) POOLING_CONNECTION_MANAGER).setDefaultMaxPerRoute(max); &#125;&#125; SSLSelfSigned.javaSSL自签证书 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.pdh.http;import java.security.KeyManagementException;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import javax.net.ssl.SSLContext;import org.apache.http.conn.ssl.NoopHostnameVerifier;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.TrustSelfSignedStrategy;import org.apache.http.ssl.SSLContexts;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 如果 https 使用自签名证书（不是第三方机构颁发的证书），无法通过验证； * 因此需要创建一个SSL连接，接受自签名证书的信任策略，使其通过验证。 * * @author pengdh * @date 2017/10/28 */public class SSLSelfSigned &#123; public static final SSLConnectionSocketFactory SSL_CONNECTION_SOCKET_FACTORY; protected static final Logger logger = LoggerFactory.getLogger(SSLSelfSigned.class); static &#123; SSLContext sslContext = null; try &#123; sslContext = SSLContexts.custom().loadTrustMaterial(TrustSelfSignedStrategy.INSTANCE).build(); &#125; catch (KeyManagementException e) &#123; logger.error("&#123;&#125;", e); &#125; catch (NoSuchAlgorithmException e) &#123; logger.error("&#123;&#125;", e); &#125; catch (KeyStoreException e) &#123; logger.error("&#123;&#125;", e); &#125; SSL_CONNECTION_SOCKET_FACTORY = new SSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE); &#125; private SSLSelfSigned() &#123; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows 环境下 vagrant 安装配置]]></title>
      <url>%2F2017%2F10%2F11%2Fvagrant-install-configure%2F</url>
      <content type="text"><![CDATA[vagrant 介绍 vagrant 是一个虚拟机运行环境管理工具，通过它我们可以快速的通过命令搭建一个比较完善的开发环境，其本身并不是虚拟机。我们经常使用的虚拟机有 VirtualBox、VMware 等。 环境和软件准备 Windows 7 旗舰版 vagrant_2.0.0_x86_64.msi VirtualBox-5.1.28-117968-Win.exe 安装步骤VirtualBox 下载到 VirtualBox 官网 https://www.virtualbox.org/wiki/Downloads 下载安装包。 vagrant 下载到 vagrant 官网 https://www.vagrantup.com/downloads.html 下载安装包，如果没有翻墙的话最好移步到我分享的百度云下载 链接：http://pan.baidu.com/s/1pLp4hfX 密码：swky 。 镜像文件下载vagrant 官网提供了很多镜像文件包，https://app.vagrantup.com/boxes/search，可以通过两种方式下载镜像，一种是直接使用命令从互联网上下载，另一种通过加装本地镜像文件来安装。这里使用第二种方式。 安装 首先我们安装了 VirtualBox 完成之后，打开 VirtualBox 使用快捷键 Ctrl + G 打开“全局设置”，选择 常规 里的 默认虚拟电脑位置，设置为非系统盘的位置。 安装了 vagrant 完成之后，vagrant 会默认设置虚拟机模板镜像文件存放在c:\User\.Vagrant.d里，当使用Vagrant管理的虚拟机模板镜像较多时，这个目录也是比较大的，需要将这个目录放到其它磁盘上。添加环境变量：VAGRANT_HOME，值设置如：D:\vagrant-projects.vagrant.d 新建目录，如：D:\vagrant-projects，用来管理虚拟机。 下载镜像文件到本地，我们可以通过如下图方式获取到镜像文件下载的地址，以 centos/7 为例：，将链接复制到浏览器手动下载。这样在浏览器里下载断了也可以续。 在 vagrant-projects 目录下新建 centos7 目录，用于存放 centos/7 文件位置。 使用命令：vagrant box add {title} {url} 加载镜像文件，其中 title 自己定义取名，url 为镜像文件位置，如： 12345678D:\vagrant-projects\centos7&gt;vagrant box add centos7-11 D:\vagrant-projects\virtualbox\CentOS-7-x86_64-Vagrant-1708_01.VirtualBox.box==&gt; box: Box file was not detected as metadata. Adding it directly...==&gt; box: Adding box 'centos7-11' (v0) for provider: box: Unpacking necessary files from: file:///D:/vagrant-projects/virtualbox/CentOS-7-x86_64-Vagrant-1708_01.VirtualBox.box box: Progress: 100% (Rate: 47.8M/s, Estimated time remaining: --:--:--)==&gt; box: Successfully added box 'centos7-11' (v0) for 'virtualbox'! 使用 vagrant init centos7-11 命令初始化虚拟机，执行完之后，发现 centos7 目录下多了个配置文件 Vagrantfile。 12345D:\vagrant-projects\centos7&gt;vagrant init centos7-11A `Vagrantfile` has been placed in this directory. You are nowready to `vagrant up` your first virtual environment! Please readthe comments in the Vagrantfile as well as documentation on`vagrantup.com` for more information on using Vagrant. 编辑 Vagrantfile 文件，将对应的注释取消掉，自定义一些配置。 配置说明 1234567891011121314151617181920#配置主机名，进入操作系统执行 hostname 显示的名字，我用的规则是 系统版本-IP#配置端口映射，通过访问本机的 8080 端口，访问安装后虚拟机的 80 端口config.vm.network "forwarded_port", guest: 80, host: 8080#配置虚拟机的 ip，默认网卡一是 NAT 方式，不需要配置#这里创建网卡二 Host-Only，对应 VirtualBox 的 vbox0config.vm.network "private_network", ip: "211.168.33.11"#配置共享文件夹目录，进入系统后，自动挂载 /dataconfig.vm.synced_folder "/vagrant-work", "/data""#VirtualBox 的配置config.vm.provider "virtualbox" do |vb|#这里配置显示在 VirtualBox 的名字，要不然是默认的一长串字符，太丑了 vb.name = "centos7-11"# #Display the VirtualBox GUI when booting the machine vb.gui = false#Customize the amount of memory on the VM: vb.memory = "1024" vb.cpus = "2" Vagrantfile 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# -*- mode: ruby -*-# vi: set ft=ruby :# All Vagrant configuration is done below. The "2" in Vagrant.configure# configures the configuration version (we support older styles for# backwards compatibility). Please don't change it unless you know what# you're doing.Vagrant.configure("2") do |config| # The most common configuration options are documented and commented below. # For a complete reference, please see the online documentation at # https://docs.vagrantup.com. # Every Vagrant development environment requires a box. You can search for # boxes at https://vagrantcloud.com/search. config.vm.box = "centos7-11" config.vm.hostname = "centos7-11" # config.ssh.username = "vagrant" # config.ssh.password = "vagrant" # Disable automatic box update checking. If you disable this, then # boxes will only be checked for updates when the user runs # `vagrant box outdated`. This is not recommended. # config.vm.box_check_update = false # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine. In the example below, # accessing "localhost:8080" will access port 80 on the guest machine. # NOTE: This will enable public access to the opened port config.vm.network "forwarded_port", guest: 80, host: 8080 # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine and only allow access # via 127.0.0.1 to disable public access # config.vm.network "forwarded_port", guest: 80, host: 8080, host_ip: "127.0.0.1" # Create a private network, which allows host-only access to the machine # using a specific IP. config.vm.network "private_network", ip: "211.168.33.11" # Create a public network, which generally matched to bridged network. # Bridged networks make the machine appear as another physical device on # your network. # config.vm.network "public_network" # Share an additional folder to the guest VM. The first argument is # the path on the host to the actual folder. The second argument is # the path on the guest to mount the folder. And the optional third # argument is a set of non-required options. config.vm.synced_folder "/vagrant-work", "/data" # Provider-specific configuration so you can fine-tune various # backing providers for Vagrant. These expose provider-specific options. # Example for VirtualBox: # config.vm.provider "virtualbox" do |vb| vb.name = "centos7-11" # # Display the VirtualBox GUI when booting the machine vb.gui = true # # # Customize the amount of memory on the VM: vb.memory = "1024" vb.cpus = "2" end # # View the documentation for the provider you are using for more # information on available options. # Enable provisioning with a shell script. Additional provisioners such as # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the # documentation for more information about their specific syntax and use. # config.vm.provision "shell", inline: &lt;&lt;-SHELL # apt-get update # apt-get install -y apache2 # SHELLend 使用 vagrant up –provider virtualbox 命令启动虚拟机 启动之后使用 vagrant ssh 登录虚拟机。 vagrant 常用命令123456789101112131415161718192021222324vagrant box add 添加box的操作vagrant init 初始化box的操作vagrant up 启动虚拟机的操作vagrant ssh 登录拟机的操作vagrant status 查看当前文件夹下虚拟机状态vagrant ssh-config 输出用于ssh连接的一些信息vagrant halt 强制关机vagrant reload 重新启动虚拟机，主要用于重新载入配置文件vagrant resume 恢复前面被挂起的状态vagrant suspend 挂起当前的虚拟机vagrant box list 显示当前已经添加的box列表vagrant box remove 删除相应的box 参考文献 http://www.cnblogs.com/vishun/archive/2017/06/02/6932454.html https://favoorr.github.io/2017/01/05/programming-road-environment/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解 JVM：Java 内存模型（一）——基础]]></title>
      <url>%2F2017%2F09%2F17%2Fjava-memory-model-01%2F</url>
      <content type="text"><![CDATA[并发编程并发：指同时发生，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。 在并发编程中需要处理两个关键问题：线程之间如何通信及线程之间如何同步。 通信：是指线程之间如何交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。 同步：是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。在 Java 中，可以通过 volatile，synchronized, 锁等方式实现同步。 Java 内存模型Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。Java 虚拟机规范中试图定义一种 Java 内存模型（Java Model Memory，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 主内存与工作内存Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然不会存在竞争问题。 Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存被该线程使用到的变量在主内存中变量的副本，线程对变量的多有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的值得传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示： 这里所讲的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上没有关系，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时注意访问读写的是工作内存。 内存间交互操作Java 内存模型定义了 8 种操作来完成主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步会主内存的。虚拟机是现实必须要保证下面提及的每一种操作都是原子的、不可再分的。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。 read（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。 load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量植入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。 write（写入）：作用于主内存的变量，它把 store 操作从工作内存得到的变量的值放入主内存的变量中。 Java 内存模型还规定了在执行上述 8 种基本操作是必须满足如下规则： 如果把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作。 如果把一个变量从工作内存同步回主内存，那就要顺序地执行 store 和 write 操作。 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生任何 assign 操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 和 assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。 一个变量在同一个时刻只允许一个线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。 参考文献 深入理解 Java 虚拟机 http://www.infoq.com/cn/articles/java-memory-model-1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解 JVM：JVM 内存模型]]></title>
      <url>%2F2017%2F09%2F16%2Fjvm-memory%2F</url>
      <content type="text"><![CDATA[Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间。有的区域随着虚拟机进程的启动就存在了， 有的区域则是依赖用户线程。根据《Java虚拟机规范（第二版）》，Java 虚拟机所管理的内存包含以下的几个区域。 运行时数据区（Runtime Data Area） 由上图可以看出，在运行时数据区中：虚拟机栈、本地方法栈、程序计数器属于线程隔离的数据区，是单个线程私有的，它们的生命周期与线程相同；而方法区和堆属于所有线程共享的数据区，是所有线程共享的。 程序计数器程序计数器（Program Counter Register）是最小的一块内存区域，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。在多线程环境下，当某个线程失去处理器执行权时，需要记录该线程被切换出去时所执行的程序位置。从而方便该线程被切换回来(重新被处理器处理)时能恢复到当初的执行位置，因此每个线程都需要有一个独立的程序计数器。各个线程的程序计数器互不影响，并且独立存储。 如果线程正在执行一个 java 方法时，这个程序计数器记录的时正在执行的虚拟机字节码指令的地址； 如果正在执行的是 Native 方法，这个计数器的值则为空（Undefined）； 此内存区域是唯一一个在 java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。 Java 虚拟机栈Java 虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。Java 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，对应着一个栈帧在虚拟机中入栈到进栈的过程。 局部变量表存放了编译期克制的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其它与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量表空间（Slot），其余的数据类型只占 1 个。局部变量所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定了的，在方法运行期间不会改变局部变量表的大小。 在 Java 虚拟机规范中，对这个区域规定了两种异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常； 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。 本地方法栈本地方法栈（Native Method Stack）虚拟机栈所发挥的作用是非常相似的，它们的区别不过是虚拟机栈为虚拟机执行 Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如 Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。 Java 堆也叫做java 堆（Java Heap）、GC 堆（Garbage Collected Heap）是 java 虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在 JVM 启动时创建。该内存区域存放了对象实例及数组(所有 new 的对象)。其大小通过 -Xms(最小值)和 -Xmx(最大值)参数设置，-Xms 为 JVM启动时申请的最小内存，默认为操作系统物理内存的 1/64 但小于 1G，-Xmx 为 JVM 可申请的最大内存，默认为物理内存的 1/4 但小于 1G，默认当空余堆内存小于 40% 时，JVM 会增大 Heap 到 -Xmx指定的大小，可通过 -XX:MinHeapFreeRation= 来指定这个比列；当空余堆内存大于 70% 时，JVM 会减小 heap 的大小到 -Xms 指定的大小，可通过 XX:MaxHeapFreeRation= 来指定这个比列，对于运行系统，为避免在运行时频繁调整 Heap 的大小，通常 -Xms 与 -Xmx 的值设成一样。 Java 堆是垃圾收集器管理的主要区域，从内存回收的角度来看，由于现在收集器基本是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代 GC(Minor GC) 任然存活的对象。 新生代： 程序新创建的对象都是从新生代分配内存，新生代由 Eden Space 和两块相同大小的Survivor Space(通常又称 S0 和 S1 或 From 和 To)构成，在 Sun HotSpot 虚拟机中 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80% + 10%），可通过 -Xmn 参数来指定新生代的大小，也可以通过 -XX:SurvivorRation 来调整 Eden Space 及 Survivor Space 的大小。 老年代： 用于存放经过多次新生代 GC 任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：1、大对象，可通过启动参数设置 -XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。2、大的数组对象，切数组中无引用外部对象。 老年代所占的内存大小为 -Xmx 对应的值减去 -Xmn 对应的值。 Young Generation 即图中的 Eden + From Space + To Space Eden 存放新生的对象 Survivor Space 有两个，存放每次垃圾回收后存活的对象 Old Generation Tenured Generation 即图中的 Old Space 主要存放应用程序中生命周期长的存活对象。 方法区方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于内存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆）。对于 HotSpot 虚拟机，也把方法区成为“永久代”（Permanent Generation），默认最小值为16MB，最大值为64MB，可以通过 -XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。在 JDK 1.7 以后已经逐步改为采用 Native Memory 来实现方法区。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中处了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。对于 HotSpot 虚拟机，在 JDK 1.7 中，已经把原本放在永久代的字符串常量池移除。 直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常。jdk1.4 中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。 参考文献 深入理解 Java 虚拟机 http://www.hollischuang.com/archives/80]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Boot 集成 socket.io 后端实现消息实时通信]]></title>
      <url>%2F2017%2F09%2F03%2Fspringboot-socketio%2F</url>
      <content type="text"><![CDATA[概述 基于 socket.io 来说，采用 node 实现更加合适，本文使用两个后端的开源框架实现，服务端使用 netty-socketio ，客户端使用 socket.io-client。使用 Scheduledexecutorservice 实现消息可配置任务调度。 socket.iosocket.io：是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库。两者有着几乎一样的API。像Node.js一样，它也是事件驱动的. Socket.IO 主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，[2]并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的包装库，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和异步IO操作。 项目搭建引入依赖包1234567891011&lt;dependency&gt; &lt;groupId&gt;io.socket&lt;/groupId&gt; &lt;artifactId&gt;socket.io-client&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.corundumstudio.socketio&lt;/groupId&gt; &lt;artifactId&gt;netty-socketio&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; 创建服务端类 SocketServer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.socket.socketio;import com.corundumstudio.socketio.AckRequest;import com.corundumstudio.socketio.Configuration;import com.corundumstudio.socketio.SocketIOClient;import com.corundumstudio.socketio.SocketIOServer;import com.corundumstudio.socketio.listener.ConnectListener;import com.corundumstudio.socketio.listener.DataListener;import com.corundumstudio.socketio.listener.DisconnectListener;import com.socket.domain.TimeMessage;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;/** * socketio 服务端 *netty-socketio 实现的 socke.io 服务端 * * @author pengdh * @date: 2017-09-03 1:13 */@Componentpublic class SocketServer &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); private static SocketIOServer server = initServer(); /** * 初始化服务端 * @return */ private static SocketIOServer initServer() &#123; Configuration config = new Configuration(); config.setHostname("localhost"); config.setPort(9090); server = new SocketIOServer(config); return server; &#125; /** * 启动服务端 */ public void startServer() &#123; // 添加连接监听 server.addConnectListener(new ConnectListener() &#123; @Override public void onConnect(SocketIOClient socketIOClient) &#123; logger.info("server 服务端启动成功"); &#125; &#125;); // 添加断开连接监听 server.addDisconnectListener(new DisconnectListener() &#123; @Override public void onDisconnect(SocketIOClient socketIOClient) &#123; logger.info("server 服务端断开连接"); &#125; &#125;); // 添加事件监听 server.addEventListener("join", String.class, new DataListener&lt;String&gt;() &#123; @Override public void onData(SocketIOClient socketIOClient, String str, AckRequest ackRequest) throws Exception &#123; logger.info("收到客户端加入消息：" + str); server.getBroadcastOperations().sendEvent("joinSuccess", "join success"); &#125; &#125;); // 添加事件监听 server.addEventListener("chatMessage", TimeMessage.class, new DataListener&lt;TimeMessage&gt;() &#123; @Override public void onData(SocketIOClient socketIOClient, TimeMessage message, AckRequest ackRequest) throws Exception &#123; logger.info("收到客户端消息：" + message.toString()); server.getBroadcastOperations().sendEvent("return message", message.toString()); &#125; &#125;); // 启动服务端 server.start(); &#125; /** * 停止服务端 */ public void stopServer() &#123; server.stop(); &#125;&#125; initServer 方法 初始化服务端本地 9090 端口； startServer 方法中，添加一系列事件监听器，并根据事件作出响应； 通过 server.start() 启动服务端，server.stop() 停止服务端； 创建客户端类 SocketClient123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270package com.socket.socketio;import com.socket.common.date.DateUtils;import io.socket.client.IO;import io.socket.client.Socket;import io.socket.emitter.Emitter.Listener;import java.net.URISyntaxException;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.concurrent.Future;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;import org.json.JSONObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;/** * socketio 客户端实现 * * @author pengdh * @date: 2017-09-03 1:06 */@Componentpublic class SocketClient &#123; // 初始化连接 private static Socket socket = initSocket(); // 初始化连接池 private static ScheduledThreadPoolExecutor scheduledExecutorService = new ScheduledThreadPoolExecutor( 10); private final Logger logger = LoggerFactory.getLogger(this.getClass()); // 连接标识 private boolean isConnected; private String onMessageContent = null; /** * 用于存放每个进来任务的 future ，key：为任务id，value：future， * 目的是为了可以通过条件控制任务，通过接口调用可以 cancel 对应的 future */ private Map&lt;String, Future&gt; futureMap = new HashMap&lt;String, Future&gt;(); /** * 连接监听事件 * 实现消息回调接口 */ private Listener onConnect = new Listener() &#123; @Override public void call(Object... objects) &#123; logger.info("client 连接服务端成功："); if (!isConnected) &#123; socket.emit("connect message", "hello"); &#125; isConnected = true; &#125; &#125;; /** * 断开连接端口监听 */ private Listener onDisconnect = new Listener() &#123; @Override public void call(Object... objects) &#123; logger.info("client 断开服务端连接：" + objects[0]); isConnected = false; &#125; &#125;; /** * 连接错误监听 */ private Listener onConnetError = new Listener() &#123; @Override public void call(Object... objects) &#123; logger.info("client 连接服务端错误：" + objects[0]); &#125; &#125;; /** * 连接超时监听 */ private Listener onConnetTimeout = new Listener() &#123; @Override public void call(Object... objects) &#123; logger.info("client 连接服务端超时：" + objects[0]); &#125; &#125;; /** * 消息监听事件 */ private Listener onMessage = new Listener() &#123; @Override public void call(Object... objects) &#123; logger.info("收到返回监听事件：" + objects[0]); onMessageContent = (String) objects[0]; &#125; &#125;; /** * 初始化 socket 连接 */ public static Socket initSocket() &#123; try &#123; socket = IO.socket("http://localhost:9090"); &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); &#125; return socket; &#125; /** * 连接处理 */ public void connectSocket() &#123; // 连接 socket.connect(); // 添加监听事件 addConnectListenerEvent(); &#125; /** * 断开连接 */ public void disConnectSocket() &#123; // 断开连接 socket.disconnect(); // 添加监听事件 addDisConnectListenerEvent(); &#125; /** * 添加连接监听事件 */ private void addConnectListenerEvent() &#123; socket.on(Socket.EVENT_CONNECT, onConnect); // 连接成功 socket.on(Socket.EVENT_DISCONNECT, onDisconnect); // 断开连接 socket.on(Socket.EVENT_CONNECT_ERROR, onConnetError);// 连接错误 socket.on(Socket.EVENT_CONNECT_TIMEOUT, onConnetTimeout); // 连接超时 &#125; /** * 添加断开连接监听事件 */ public void addDisConnectListenerEvent() &#123; socket.off(Socket.EVENT_CONNECT, onConnect); // 连接成功 socket.off(Socket.EVENT_DISCONNECT, onDisconnect); // 断开连接 socket.off(Socket.EVENT_CONNECT_ERROR, onConnetError);// 连接错误 socket.off(Socket.EVENT_CONNECT_TIMEOUT, onConnetTimeout); // 连接超时 &#125; /** * 启动客户端并指定发送消息任务开始时间 * @param id 指定的任务id * @param startTime 任务开始时间 */ public void startClient(String id, String startTime) &#123; try &#123; this.judgeConnection(); this.judgeHandleExistFuture(id); this.emitJoined(id); // 指定从当前时间延迟多久后开始执行定时的任务，时间单位可以在调用方法时指定 long delay = 0; // 指定每次执行任务的时间间隔 long period = 10000; Date date = DateUtils.parseShortDateTime(startTime); // 计算任务开始时间到当前时间的毫秒差 long targetTimeMillis = date.getTime(); long initDelay = targetTimeMillis - System.currentTimeMillis(); delay = initDelay &gt; 0 ? initDelay : delay; logger.info("启动定时任务：delay=" + delay + " period=" + period); // 因为每天会定时结束所有服务，当再次有任务进来时要先初始化线程池 if (scheduledExecutorService.isShutdown()) &#123; scheduledExecutorService = new ScheduledThreadPoolExecutor(10); &#125; Future future = scheduledExecutorService .scheduleAtFixedRate(new HandleMessageRunnable(id), delay, period, TimeUnit.MILLISECONDS); // 将 future 放入map futureMap.put(id, future); logger.info("已有客户端：" + futureMap.keySet()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 加入事件监听 * @param id */ private void emitJoined(String id) &#123; socket.emit("join", id).on("joinSuccess", onMessage); &#125; /** * 判断连接 */ private void judgeConnection() &#123; if (!isConnected) &#123; this.initSocket(); this.connectSocket(); &#125; &#125; /** * cancel 任务 * @param id */ public void judgeHandleExistFuture (String id) &#123; if (futureMap.containsKey(id)) &#123; Future future = futureMap.get(id); future.cancel(true); futureMap.remove(id); logger.info(id + " task cancelled!"); logger.info("剩余客户端：" + futureMap.keySet()); &#125; &#125; /** * cancel 掉 id 对应的任务 */ public void endClient(String id) &#123; try &#123; this.judgeHandleExistFuture(id); &#125; catch (Throwable e) &#123; logger.error(e.getMessage()); &#125; &#125; /** * 结束所有任务 */ public void shutdown() &#123; scheduledExecutorService.shutdown(); futureMap.clear(); logger.info("task have shutdown!"); &#125; /** * 处理任务 * 通过固定频率发送消息到服务端 */ private class HandleMessageRunnable implements Runnable &#123; private String id; public HandleMessageRunnable(String id) &#123; this.id = id; &#125; @Override public void run() &#123; JSONObject jsonObject = new JSONObject(); try &#123; // 先发送 joined 事件，当收到回执后再发送 chatMessage 消息 if (null != onMessageContent &amp;&amp; onMessageContent.equals("join success")) &#123; String currentTime = DateUtils.formatStandardDateTime(new Date()); jsonObject.put("id", id); jsonObject.put("currentTime", currentTime); logger.info("客户端发送消息：" + jsonObject.toString()); socket.emit("chatMessage", jsonObject); &#125; else &#123; logger.info("未收到加入返回事件"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 通过 initSocket 初始化客户端，初始化地址 http://localhost:9090； 通过 new ScheduledThreadPoolExecutor(10)，初始化任务调度线程池； 使用 Map 用于存放每个进来任务的 future ，key：为任务id，value：future，目的是为了可以通过条件控制任务，通过接口调用可以 cancel 对应的 future； 通过 connectSocket 连接服务端，并调用 addConnectListenerEvent 添加一些列监听事件； 通过 startClient 启动任务。 通过 HandleMessageRunnable 类实现具体消息的处理。 创建定时任务调度控制器 ScheduledController1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.socket.web;import com.socket.socketio.SocketClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * 定时任务调度控制器 * * @author pengdh * @date: 2017-09-03 1:53 */@RestControllerpublic class ScheduledController &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private SocketClient client; /** * 启动客户端任务 * @param id 任务id * @param startTime 任务开始时间 * @return */ @RequestMapping("/start/&#123;id&#125;") public ResponseEntity&lt;String&gt; startClient(@PathVariable String id, @RequestParam String startTime) &#123; client.startClient(id, startTime); return new ResponseEntity&lt;String&gt;(HttpStatus.NO_CONTENT); &#125; /** * 取消消息任务 * @param id * @return */ @RequestMapping("/end/&#123;id&#125;") public ResponseEntity&lt;String&gt; endClient(@PathVariable String id) &#123; client.endClient(id); return new ResponseEntity&lt;String&gt;(HttpStatus.NO_CONTENT); &#125; /** * 通过接口调用手动结束所有任务 * * @return */ @RequestMapping("/end") public ResponseEntity&lt;String&gt; shutdown() &#123; logger.info("手动结束所有任务"); client.shutdown(); return new ResponseEntity&lt;String&gt;(HttpStatus.NO_CONTENT); &#125; /** * 定时结束所有任务 */ @Scheduled(cron = "0 0 2 * * ?") public void stopClient() &#123; logger.info("定时结束所有任务"); client.shutdown(); &#125;&#125; 调用 http://localhost:8080/socket-demo/start/{id}?startTime=yyyyMMddHHmmss 接口可以控制指定任务在指定时间开始执行； 调用 http://localhost:8080/socket-demo/end/{id} 取消指定任务； 调用 http://localhost:8080/socket-demo/end 可以手动接收当前在执行的所有任务，scheduledExecutorService.shutdown() 不会强制所有任务立即停止，而是会在正在执行的本次任务执行完后才 shutdown； 这里使用到了 @Scheduled ，需要到 Application 类中的加上 @EnableScheduling 注解以开启定时任务； stopClient 方法可以定时结束所有任务，以节省资源，这个根据业务自身决定是否需要。 修改 Appingcation 类12345678910111213141516171819package com.socket;import com.socket.socketio.SocketServer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableScheduling@ComponentScanpublic class SpringbootSocketApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootSocketApplication.class, args); SocketServer server = new SocketServer(); server.startServer(); &#125;&#125; 运行效果 启动项目 调用 http://localhost:8080/socket-demo/start/{id}?startTime=yyyyMMddHHmmss 接口启动任务。 查看控制台信息,注意 2 的时间和现在的时间，未到时间： 到时间：; 再次调用 http://localhost:8080/socket-demo/start/{id}?startTime=yyyyMMddHHmmss 加入新任务：； http://localhost:8080/socket-demo/end/{id}，可以取消任务。 http://localhost:8080/socket-demo/end 结束所有任务。 源码地址： https://github.com/alexpdh/springboot-demo/tree/master/springboot-socket]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring Boot 集成 WebSocket 基于 STOMP 实现消息实时通信]]></title>
      <url>%2F2017%2F09%2F02%2Fspringboot-websocket%2F</url>
      <content type="text"><![CDATA[概述Spring BootSpring Boot：是为了简化使用 Spring 开发的应用产生的，它使用“习惯由于配置”的理念使项目快速运行起来。使用 Spring Boot 你可以不用或者只需要很少的 Spring 配置，你可以仅仅使用一个 java -jar 命令就运行起一个 java 项目。 优点 快速构建项目。 开箱即用，提供各种默认配置来简化项目配置。 项目可以独立运行，无须外部依赖 Servlet 容器。 对主流框架的无配置集成。 提供各种 starter 简化 Maven 配置。 WebSocketWebSocket：是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket 通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI 被W3C定为标准。 在WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 特点 为浏览器和服务端提供了双工异步通信的功能，即服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 STOMPSTOMP：即Simple (or Streaming) Text Orientated Messaging Protocol，它是一个简单的文本消息传输协议，属于 WebSocket 的子协议，提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。 优点 使用 WebSocket 需要增加浏览器的兼容支持，如 IE 10+、Chrome 13+、Firefox 6+，而 STOMP 是一个更高级的协议，它使用一个基于帧（frame）的格式来定义消息，与 HTTP 的 request 和 response 类似。 项目构建添加 WebSocket 和 Thymeleaf 依赖 新建 websocket 配置类1234567891011121314151617181920212223242526272829package com.socket.websocket;import org.springframework.context.annotation.Configuration;import org.springframework.messaging.simp.config.MessageBrokerRegistry;import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;/** * websocket 配置类 * * @author pengdh * @date: 2017-09-02 15:46 */@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123; @Override public void registerStompEndpoints(StompEndpointRegistry stompEndpointRegistry) &#123; stompEndpointRegistry.addEndpoint("/endpointWeb").withSockJS();; &#125; @Override public void configureMessageBroker(MessageBrokerRegistry messageBrokerRegistry) &#123; messageBrokerRegistry.enableSimpleBroker("/topic"); &#125;&#125; 通过 @EnableWebSocketMessageBroker 注解来开启使用 STOMP 协议来传输基于代理（message broker）的消息。 通过复写父类的 registerStompEndpoints 方法，注册 STOMP 协议的节点来映射指定的 URL 并指定使用 SocketJS 协议。 通过复写父类的 configureMessageBroker 方法，来配置一个广播式消息代理。 新建浏览器像服务端发送消息封装类 ClientRequestMessage12345678910111213141516package com.socket.websocket;/** * 浏览器像服务端发送消息封装类 * * @author pengdh * @date: 2017-09-02 16:10 */public class ClientRequestMessage &#123; private String name; public String getName() &#123; return name; &#125;&#125; 新建服务端像浏览器端发送消息封装类 ServerResponseMessage123456789101112131415161718192021package com.socket.websocket;/** * 服务端像浏览器端发送消息封装类 * * @author pengdh * @date: 2017-09-02 16:13 */public class ServerResponseMessage &#123; private String responseMessage; public ServerResponseMessage(String responseMessage) &#123; this.responseMessage = responseMessage; &#125; public String getResponseMessage() &#123; return responseMessage; &#125;&#125; 新建请求控制器 WsController12345678910111213141516171819202122package com.socket.websocket;import org.springframework.messaging.handler.annotation.MessageMapping;import org.springframework.messaging.handler.annotation.SendTo;import org.springframework.stereotype.Controller;/** * 请求控制器 * * @author pengdh * @date: 2017-09-02 16:16 */@Controllerpublic class WsController &#123; @MessageMapping("/welcome") @SendTo("/topic/getResponse") public ServerResponseMessage say(ClientRequestMessage message) &#123; System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; " + message.getName()); return new ServerResponseMessage("Welcome," + message.getName() + "!"); &#125;&#125; 通过 @MessageMapping 注解接收浏览器端发送的消息。 通过 @SendTo 注解像浏览器端广播消息。 构建浏览器端 需要下载 stomp.js、sockjs.min.js、jquery.js 几个脚本支持。将几个文件放在 src/main/resources/static 下。 演示页面 ws.html 放在 src/main/resources/templates 下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;广播式WebSocket&lt;/title&gt; &lt;script th:src="@&#123;js/sockjs.min.js&#125;"&gt;&lt;/script&gt; &lt;script th:src="@&#123;js/stomp.js&#125;"&gt;&lt;/script&gt; &lt;script th:src="@&#123;js/jquery-3.1.1.js&#125;"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body onload="disconnect()"&gt;&lt;noscript&gt;&lt;h2 style="color: #e80b0a;"&gt;Sorry，浏览器不支持WebSocket&lt;/h2&gt;&lt;/noscript&gt;&lt;div&gt; &lt;div&gt; &lt;button id="connect" onclick="connect();"&gt;连接&lt;/button&gt; &lt;button id="disconnect" disabled="disabled" onclick="disconnect();"&gt;断开连接&lt;/button&gt; &lt;/div&gt; &lt;div id="conversationDiv"&gt; &lt;label&gt;输入你的名字&lt;/label&gt;&lt;input type="text" id="name"/&gt; &lt;button id="sendName" onclick="sendName();"&gt;发送&lt;/button&gt; &lt;p id="response"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var stompClient = null; function setConnected(connected) &#123; document.getElementById("connect").disabled = connected; document.getElementById("disconnect").disabled = !connected; document.getElementById("conversationDiv").style.visibility = connected ? 'visible' : 'hidden'; $("#response").html(); &#125; function connect() &#123; var socket = new SockJS('/endpointWeb'); stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function (frame) &#123; setConnected(true); console.log('Connected:' + frame); stompClient.subscribe('/topic/getResponse', function (response) &#123; showResponse(JSON.parse(response.body).responseMessage); &#125;) &#125;); &#125; function disconnect() &#123; if (stompClient != null) &#123; stompClient.disconnect(); &#125; setConnected(false); console.log('Disconnected'); &#125; function sendName() &#123; var name = $('#name').val(); console.log('name:' + name); stompClient.send("/welcome", &#123;&#125;, JSON.stringify(&#123;'name': name&#125;)); &#125; function showResponse(message) &#123; $("#response").html(message); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新建 WebMvcConfig 类123456789101112131415161718192021package com.socket.websocket;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;/** * viewController * 为ws.html提供路径映射 * * @author pengdh * @date: 2017-09-02 16:18 */@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/ws").setViewName("/ws"); &#125;&#125; 运行效果 参考文献 Spring Boot 实战 http://www.ruanyifeng.com/blog/2017/05/websocket.html 源码地址：https://github.com/alexpdh/springboot-demo/tree/master/springboot-socket]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（二十五）：访问者模式]]></title>
      <url>%2F2017%2F08%2F19%2Fvisitor-pattern%2F</url>
      <content type="text"><![CDATA[访问者模式（Visitor Pattern）访问者模式（Visitor Pattern）：属于类的行为模式。表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 访问者模式UML图 访问者模式涉及的角色抽象访问者（Visitor）角色：为该对象结构中 ConcreteElement 的每一个类声明一个 visite 操作。具体访问者(ConcreteVisitor)角色：实现每个由 visitor 声明的操作。每个操作实现算法的一部分，而该算法片段乃是对应于结构中的对象的类。抽象元素（Element）角色：定义一个 accept 操作，它以一个访问者为参数。具体元素（ConcreteElement）角色：实现了抽象元素所规定的接受操作。结构对象(ObjectStructure)角色：有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。 示例代码抽象访问者类 Visitor 123456789101112131415161718192021222324package com.example.visitorPattern;/** * 访问者模式：访问者类 * * @author pengdh * @date: 2017-08-19 17:24 */public abstract class Visitor &#123; /** * 对应于 ConcreteElementA 的访问操作 * * @param concreteElementA 具体元素 A */ public abstract void visitConcreteElementA(ConcreteElementA concreteElementA); /** * 对应于 ConcreteElementB 的访问操作 * * @param concreteElementB 具体元素 B */ public abstract void visitConcreteElementB(ConcreteElementB concreteElementB);&#125; 具体访问者1类 ConcreteVisitor1 1234567891011121314151617181920package com.example.visitorPattern;/** * 访问者模式：具体访问者1 * * @author pengdh * @date: 2017-08-19 17:35 */public class ConcreteVisitor1 extends Visitor &#123; @Override public void visitConcreteElementA(ConcreteElementA concreteElementA) &#123; System.out.println(ConcreteElementA.class.getSimpleName() + " 被 " + this.getClass().getSimpleName() + " 访问！"); &#125; @Override public void visitConcreteElementB(ConcreteElementB concreteElementB) &#123; System.out.println(ConcreteElementB.class.getSimpleName() + " 被 " + this.getClass().getSimpleName() + " 访问！"); &#125;&#125; 具体访问者2类 ConcreteVisitor2 1234567891011121314151617181920package com.example.visitorPattern;/** * 访问者模式：具体访问者2 * * @author pengdh * @date: 2017-08-19 17:36 */public class ConcreteVisitor2 extends Visitor &#123; @Override public void visitConcreteElementA(ConcreteElementA concreteElementA) &#123; System.out.println(ConcreteElementA.class.getSimpleName() + " 被 " + this.getClass().getSimpleName() + " 访问！"); &#125; @Override public void visitConcreteElementB(ConcreteElementB concreteElementB) &#123; System.out.println(ConcreteElementB.class.getSimpleName() + " 被 " + this.getClass().getSimpleName() + " 访问！"); &#125;&#125; 抽象元素类 Element 1234567891011121314151617package com.example.visitorPattern;/** * 访问者模式：抽象元素类 * * @author pengdh * @date: 2017-08-19 17:25 */public abstract class Element &#123; /** * 接收操作 * * @param visitor 访问者类 */ public abstract void accept(Visitor visitor);&#125; 具体元素类A ConcreteElementA 12345678910111213141516171819202122package com.example.visitorPattern;/** * 访问者模式：具体元素类A * * @author pengdh * @date: 2017-08-19 17:28 */public class ConcreteElementA extends Element &#123; @Override public void accept(Visitor visitor) &#123; visitor.visitConcreteElementA(this); &#125; /** * ConcreteElementA 特有方法 */ public void operationA() &#123; &#125;&#125; 具体元素类B ConcreteElementB 12345678910111213141516171819202122package com.example.visitorPattern;/** * 访问者模式：具体元素类B * * @author pengdh * @date: 2017-08-19 17:29 */public class ConcreteElementB extends Element &#123; @Override public void accept(Visitor visitor) &#123; visitor.visitConcreteElementB(this); &#125; /** * ConcreteElementB 特有方法 */ public void operationB() &#123; &#125;&#125; 结构对象类 ObjectStructure 123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.visitorPattern;import java.util.ArrayList;import java.util.List;/** * 访问者模式：结构对象类 * * @author pengdh * @date: 2017-08-19 20:05 */public class ObjectStructure &#123; private List&lt;Element&gt; elements = new ArrayList&lt;Element&gt;(); /** * 添加元素 * * @param element */ public void attach(Element element) &#123; elements.add(element); &#125; /** * 移除元素 * @param element */ public void deatch(Element element) &#123; elements.remove(element); &#125; /** * 执行方法 * * @param visitor */ public void accept(Visitor visitor) &#123; for (Element e : elements) &#123; e.accept(visitor); &#125; &#125;&#125; 客户端测试类 VisitorPatternTest 12345678910111213141516171819202122232425package com.example.visitorPattern;/** * 访问者模式：客户端测试类 * * @author pengdh * @date: 2017-08-19 20:04 */public class VisitorPatternTest &#123; public static void main(String[] args) &#123; // 创建一个结构对象 ObjectStructure o = new ObjectStructure(); // 给结构添加元素 o.attach(new ConcreteElementA()); o.attach(new ConcreteElementB()); // 创建访问者 Visitor v1 = new ConcreteVisitor1(); Visitor v2 = new ConcreteVisitor2(); o.accept(v1); o.accept(v2); &#125;&#125; 执行过程 客户端创建一个结构对象 ObjectStructure，将一个新的 ConcreteElementA 和一个新的 ConcreteElementB传入。 客户端创建一个 ConcreteVisitor1 和一个 ConcreteVisitor2 对象，并将对应的两个对象传入结构对象中。 客户端调用结构对象聚集管理方法，将 ConcreteElementA 和 ConcreteElementB 节点加入到结构对象中去。 客户端调用结构对象的接受方法 accept()，启动访问过程。 ConcreteElementA 对象的接受方法 accept() 被调用，并将 ConcreteVisitor1 对象本身传入； ConcreteElementA 对象反过来调用 ConcreteVisitor1 对象的访问方法，并将 ConcreteElementA 对象本身传入； ConcreteVisitor1 对象调用 输出对应信息。 ConcreteElementB 与 ConcreteVisitor2 执行过程类似。 双重分派宗量：一个方法所属的对象叫做方法的接收者，方法的接收者与方法的参数统称做方法的宗量。双重分派：一个方法根据两个宗量的类型来决定执行不同的代码，这就是“双重分派”。 上面的 5 6 7 8 步骤就是一个双重分派过程。 访问者模式的优点好的扩展性：能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。好的复用性：可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。分离无关行为： 可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。 访问者模式的缺点对象结构变化很困难：不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。破坏封装：访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（二十四）：解释器模式]]></title>
      <url>%2F2017%2F08%2F14%2Finterpreter-pattern%2F</url>
      <content type="text"><![CDATA[解释器模式（Interpreter Pattern）解释器模式（Interpreter Pattern）:属于对象的行为模式。给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 解释器模式UML图 解释器模式涉及的角色抽象表达式（AbstractExpression）角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。终结符表达式（TerminalExpression）角色：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。非终结符表达式（NonTerminalExpression ）角色：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。 示例代码环境类 InterpreterContext 12345678910111213141516171819202122232425262728package com.example.interpreterPattern;/** * 解释器模式：环境类 * * @author pengdh * @date: 2017-08-13 23:56 */public class InterpreterContext &#123; private String input; private String output; public String getInput() &#123; return input; &#125; public void setInput(String input) &#123; this.input = input; &#125; public String getOutput() &#123; return output; &#125; public void setOutput(String output) &#123; this.output = output; &#125;&#125; 抽象表达式类 AbstractExpresstion 12345678910111213141516package com.example.interpreterPattern;/** * 解释器模式：抽象表达式类 * * @author pengdh * @date: 2017-08-13 23:57 */public abstract class AbstractExpresstion &#123; /** * 以给定的环境为准，解释给定的任何一个表达式 * @param context */ public abstract void interpret(InterpreterContext context);&#125; 终结符表达式类 TerminalExpression 123456789101112131415package com.example.interpreterPattern;/** * 解释器模式：终结符表达式类 * * @author pengdh * @date: 2017-08-14 0:01 */public class TerminalExpression extends AbstractExpresstion &#123; @Override public void interpret(InterpreterContext context) &#123; System.out.println("终端解释器"); &#125;&#125; 非终结表达式类 NonTerminalExpresstion 123456789101112131415package com.example.interpreterPattern;/** * 解释器模式：非终结表达式类 * * @author pengdh * @date: 2017-08-14 0:04 */public class NonTerminalExpresstion extends AbstractExpresstion &#123; @Override public void interpret(InterpreterContext context) &#123; System.out.println("非终端解释器"); &#125;&#125; 客户端测试类 InterpreterPatternTest 123456789101112131415161718192021222324package com.example.interpreterPattern;import java.util.ArrayList;import java.util.List;/** * 解释器模式：客户端测试类 * * @author pengdh * @date: 2017-08-14 0:05 */public class InterpreterPatternTest &#123; public static void main(String[] args) &#123; InterpreterContext context = new InterpreterContext(); List&lt;AbstractExpresstion&gt; list = new ArrayList&lt;AbstractExpresstion&gt;(); list.add(new TerminalExpression()); list.add(new NonTerminalExpresstion()); list.add(new TerminalExpression()); for (AbstractExpresstion exp : list) &#123; exp.interpret(context); &#125; &#125;&#125; 解释器模式优点很容易改变和扩展文法，因为解释器模式使用类来表示文法规则，你可以使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。 解释器模式缺点解释器模式为文法中的每一条规则至少定义一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术来处理。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（二十三）：享元模式]]></title>
      <url>%2F2017%2F08%2F13%2Fflyweight-pattern%2F</url>
      <content type="text"><![CDATA[享元模式（Flyweight Pattern）享元模式（Flyweight Pattern）：属于对象的结构模式。运用共享技术有效地支持大量细粒度的对象。 享元模式UML图 享元模式涉及的角色抽象享元（Flyweight）角色：所有有具体享元类的超类或接口，通过这个接口，Flyweight 可以接受并作用于外部状态。具体享元（ConcreteFlyweight）角色：实现抽象享元角色所规定出的接口。如果有内部状态时，为内部状态提供存储空间。未共享的具体享元（UnShargedFlyweight）角色：指那些不需要共享的 Flyweight 子类，因为 Flyweight抽象类共享成为可能，但它并不强制共享。享元工厂（FlyweightFactory）角色：一个享元工厂，用来创建并管理 Flyweight 对象，它主要是用来确保合理地共享 Flyweight，当用户请求一个 Flyweight 时，FlyweightFactory 对象听歌一个已创建的实例或者创建一个（如果不存在的话）。 示例代码抽象享元类 Flyweight 1234567891011121314151617package com.example.flyweightPattern;/** * 享元模式：抽象享元类 * * @author pengdh * @date: 2017-08-13 17:09 */public abstract class Flyweight &#123; /** * 外部状态作为参数传入方法中， * 改变了方法的行为，但是并不改变对象的内部状态 * @param extrinsicstate 外部状态 */ public abstract void operation(int extrinsicstate);&#125; 具体享元类 ConcreteFlyweight 12345678910111213141516171819202122232425262728293031323334package com.example.flyweightPattern;/** * 享元模式：具体享元类 * * @author pengdh * @date: 2017-08-13 17:12 */public class ConcreteFlyweight extends Flyweight &#123; /** * 持有一个内部状态 */ private String intrinsicstate; /** * 构造函数，内部状态作为参数传入 * @param intrinsicstate */ public ConcreteFlyweight(String intrinsicstate) &#123; this.intrinsicstate = intrinsicstate; &#125; /** * 外部状态作为参数传入方法中， * 改变了方法的行为，但是并不改变对象的内部状态 * @param extrinsicstate 外部状态 */ @Override public void operation(int extrinsicstate) &#123; System.out.println("Intrinsic State：" + intrinsicstate); System.out.println("Extrinsic State：" + extrinsicstate); &#125;&#125; 非共享具体享元类 UnSharedConcreteFlyweiht 123456789101112131415package com.example.flyweightPattern;/** * 享元模式：非共享具体享元类 * * @author pengdh * @date: 2017-08-13 17:15 */public class UnSharedConcreteFlyweiht extends Flyweight &#123; @Override public void operation(int extrinsicstate) &#123; System.out.println("非共享的具体 Flyweiht：" + extrinsicstate); &#125;&#125; 享元工厂类 FlyweihtFactory 12345678910111213141516171819202122package com.example.flyweightPattern;import java.util.HashMap;import java.util.Map;/** * 享元模式：享元工厂类 * * @author pengdh * @date: 2017-08-13 17:17 */public class FlyweihtFactory &#123; private Map&lt;String, Flyweight&gt; map = new HashMap&lt;String, Flyweight&gt;(); public Flyweight create(String intrinsicstate) &#123; if (!map.containsKey(intrinsicstate)) &#123; map.put(intrinsicstate, new ConcreteFlyweight(intrinsicstate)); &#125; return map.get(intrinsicstate); &#125;&#125; 客户端测试类 FlyweightPatternTest 1234567891011121314151617181920212223242526272829303132333435package com.example.flyweightPattern;/** * 享元模式：客户端测试类 * * @author pengdh * @date: 2017-08-13 17:24 */public class FlyweightPatternTest &#123; public static void main(String[] args) &#123; int extrinsicstate = 22; FlyweihtFactory factory = new FlyweihtFactory(); Flyweight f1 = factory.create("X"); f1.operation(21); Flyweight f2 = factory.create("Y"); f2.operation(20); Flyweight f3 = factory.create("X"); f3.operation(19); boolean flag = false; if (f1 == f3) &#123; flag = true; &#125; System.out.println("内部状态是否可以共享：" + flag); Flyweight uf1 = new UnSharedConcreteFlyweiht(); uf1.operation(18); &#125;&#125; 享元模式使用场景一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费时可以考虑使用；对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。 享元模式优点 它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。 享元模式缺点 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（二十二）：中介者模式]]></title>
      <url>%2F2017%2F08%2F13%2Fmediator-pattern%2F</url>
      <content type="text"><![CDATA[中介者模式（Mediator Pattern）中介者模式（Mediator Pattern）：属于对象的行为模式。又叫调停者模式，用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。 中介者模式UML图 中介者模式涉及的角色抽象中介者（Mediator）角色：定义了同事对象到中介者对象的接口。具体中介者（ConcreteMediator）角色：实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。抽象同事（Colleague）角色：定义出中介者到同事对象的接口。同事对象只知道中介者而不知道其余的同事对象。具体同事（ConcreteColleague）角色：每个具体同事只知道自己的行为，而不了解其它同事类的情况，但它们却都认识中介者对象。 示例代码抽象中介者类 Mediator 12345678910111213141516171819package com.example.mediatorPattern;/** * 中介者模式：中介者抽象类 * * @author pengdh * @date: 2017-08-13 2:46 */public abstract class Mediator &#123; /** * 同事对象在自身发生改变的时候来通知中介者方法 * 让中介者来负责与其它同事对象的交互 * * @param messge 消息 * @param colleague 同事对象 */ protected abstract void send(String messge, Colleague colleague);&#125; 抽象同事类 Colleague 1234567891011121314151617package com.example.mediatorPattern;/** * 中介者模式：抽象同事类 * * @author pengdh * @date: 2017-08-13 2:48 */public abstract class Colleague &#123; // 持有一个中介者对象 protected Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125; 具体同事类A ConcreteColleagueA 123456789101112131415161718192021222324252627282930313233package com.example.mediatorPattern;/** * 中介者模式：具体同事类A * * @author pengdh * @date: 2017-08-13 2:52 */public class ConcreteColleagueA extends Colleague &#123; public ConcreteColleagueA(Mediator mediator) &#123; super(mediator); &#125; /** * 发送消息 * * @param messge */ public void send(String messge) &#123; mediator.send(messge,this); &#125; /** * 获取消息 * * @param message */ public void getMessage(String message) &#123; System.out.println("同事A得到消息：" + message); &#125;&#125; 具体同事类B ConcreteColleagueB 1234567891011121314151617181920212223242526272829303132package com.example.mediatorPattern;/** * 中介者模式：具体同事类B * * @author pengdh * @date: 2017-08-13 3:04 */public class ConcreteColleagueB extends Colleague &#123; public ConcreteColleagueB(Mediator mediator) &#123; super(mediator); &#125; /** * 发送消息 * * @param messge */ public void send(String messge) &#123; mediator.send(messge,this); &#125; /** * 获取消息 * * @param message */ public void getMessage(String message) &#123; System.out.println("同事B得到消息：" + message); &#125;&#125; 客户端测试类 MediatorPatternTest 123456789101112131415161718192021222324package com.example.mediatorPattern;/** * 中介者模式：客户端测试类 * * @author pengdh * @date: 2017-08-13 3:14 */public class MediatorPatternTest &#123; public static void main(String[] args) &#123; ConcreteMediator mediator = new ConcreteMediator(); // 使同事对象持有中介者对象 ConcreteColleagueA colleagueA = new ConcreteColleagueA(mediator); ConcreteColleagueB colleagueB = new ConcreteColleagueB(mediator); // 使中介者持有并维护两个同事类 mediator.setColleagueA(colleagueA); mediator.setColleagueB(colleagueB); colleagueA.send("吃过饭了吗？"); colleagueB.send("没有呢"); &#125;&#125; 中介者模式的优点 松散耦合 中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。 集中控制交互 多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。 多对多变成一对多 没有使用中介者模式的时候，同事对象之间的关系通常是多对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对多，这会让对象的关系更容易理解和实现。 中介者模式的缺点 调停者模式的一个潜在缺点是，过度集中化。如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到调停者的时候，会导致调停者对象变得十分复杂，而且难于管理和维护。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（二十一）：职责链模式]]></title>
      <url>%2F2017%2F08%2F12%2Fchain-of-responsibility-pattern%2F</url>
      <content type="text"><![CDATA[职责链模式（Chain Of Responsibility Pattern）职责链模式（Chain Of Responsibility Pattern）：属于对象的行为模式。使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 职责链模式UML图 职责链模式涉及的角色抽象处理者（Handler）角色：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。具体处理者(ConcreteHandler)角色：处理它所负责的请求，由于持有对下家的引用，所以可以访问它的后继者，如果可以处理该请求，就处理之，否则将该请求转发给它的后继者。 示例代码抽象处理者 Handler 12345678910111213141516171819202122232425262728package com.example.chainOfResponsebilityPattern;/** * 职责链模式：抽象处理者 * * 定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。 * 这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用， * 抽象方法handleRequest()规范了子类处理请求的操作。 * * @author pengdh * @date: 2017-08-12 14:05 */public abstract class Handler &#123; protected Handler successor; /** * 持有对下家的引用 */ public void setSuccessor(Handler successor) &#123; this.successor = successor; &#125; /** * 请求处理 */ protected abstract void handlerRequest(int request);&#125; 具体处理者类 A ConcreteHandlerA 12345678910111213141516171819202122package com.example.chainOfResponsebilityPattern;/** * 职责链模式：具体处理者类 A * * 处理它所负责的请求，由于持有对下家的引用，所以可以访问它的后继者， * 如果可以处理该请求，就处理之，否则将该请求转发给它的后继者。 * * @author pengdh * @date: 2017-08-12 14:10 */public class ConcreteHandlerA extends Handler &#123; @Override protected void handlerRequest(int request) &#123; if (request &gt;= 0 &amp;&amp; request &lt; 10) &#123; System.out.println("处理 0-10 请求"); &#125; else &#123; successor.handlerRequest(request); // 转移到后继者类处理 &#125; &#125;&#125; 具体处理者类 B ConcreteHandlerB 12345678910111213141516171819202122package com.example.chainOfResponsebilityPattern;/** * 职责链模式：具体处理者类 B * * 处理它所负责的请求，由于持有对下家的引用，所以可以访问它的后继者， * 如果可以处理该请求，就处理之，否则将该请求转发给它的后继者。 * * @author pengdh * @date: 2017-08-12 14:17 */public class ConcreteHandlerB extends Handler &#123; @Override protected void handlerRequest(int request) &#123; if (request &gt;= 10 &amp;&amp; request &lt; 20) &#123; System.out.println("处理 10-20 的请求"); &#125; else &#123; successor.handlerRequest(request); // 转移到后继者类处理 &#125; &#125;&#125; 客户端测试类 ChainOfResponsibilityPatternTest 12345678910111213141516171819202122package com.example.chainOfResponsebilityPattern;/** * 职责链模式：客户端测试类 * * @author pengdh * @date: 2017-08-12 14:21 */public class ChainOfResponsibilityPatternTest &#123; public static void main(String[] args) &#123; Handler h1 = new ConcreteHandlerA(); Handler h2 = new ConcreteHandlerB(); // 持有一个对后继者的引用 h1.setSuccessor(h2); int[] arrays = &#123;1, 15, 3, 11&#125;; for (int request : arrays) &#123; h1.handlerRequest(request); &#125; &#125;&#125; 职责链模式的优点客户端提交请求后，请求是沿着链传递直到有一个具体处理者对象处理它，这样做的好处是客户端可以不用管请求由哪个对象来处理。这使得接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构，结构是职责链可以简化对象的相互连接，它们只需保持一个对后继者的引用，而不需要保持它的所有候选接收者。从而大大降低了耦合度。但是也要注意的是职责链模式的具体处理是有末端的，也就是说会有请求得不到处理的情况，所以客户端在发送请求的时候需要注意是否有对应的具体处理者不能处理的情况。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（二十）：命令模式]]></title>
      <url>%2F2017%2F08%2F01%2Fcommand-pattern%2F</url>
      <content type="text"><![CDATA[命令模式（command pattern）命令模式（command pattern）：属于对象的行为模式。将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销操作。 命令模式UML图 命令模式涉及的角色客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。命令(Command)角色：声明了一个给所有具体命令类的抽象接口。具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。 示例代码接收者类 Receiver 1234567891011121314151617package com.example.commandPattern;/** * 命令模式：接收者类 * * @author pengdh * @date: 2017-08-01 22:19 */public class Receiver &#123; /** * 真正执行命令相应的操作 */ public void action() &#123; System.out.println("执行请求操作！"); &#125;&#125; 命令接口 Command 123456789101112131415package com.example.commandPattern;/** * 命令模式：命令接口 * * @author pengdh * @date: 2017-08-01 22:23 */public interface Command &#123; /** * 执行命令请求 */ void execute();&#125; 具体命令类 ConcreteCommand 123456789101112131415161718192021222324package com.example.commandPattern;/** * 命令模式：具体命令类 * @author pengdh * @date: 2017-08-01 22:25 */public class ConcreteCommand implements Command &#123; /** * 持有相应的接收者对象 */ private Receiver receiver; public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void execute() &#123; //通常会转调接收者对象的相应方法，让接收者来真正执行功能 receiver.action(); &#125;&#125; 请求者类 Invoker 1234567891011121314151617181920212223242526package com.example.commandPattern;/** * 命令模式：请求者类 * * @author pengdh * @date: 2017-08-01 22:27 */public class Invoker &#123; /** * 命令对象 */ private Command command; public Invoker(Command command) &#123; this.command = command; &#125; /** * 行动方法 */ public void action() &#123; command.execute(); &#125;&#125; 客户端测试类 CommandPatternTest 1234567891011121314151617package com.example.commandPattern;/** * 命令模式：客户端测试类 * * @author pengdh * @date: 2017-08-01 22:29 */public class CommandPatternTest &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); Command command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(command); invoker.action(); &#125;&#125; 命令模式的优点 松散的耦合 命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。 动态的控制 命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。 很自然的复合命令 命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。 更好的扩展性 由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十九）：桥接模式]]></title>
      <url>%2F2017%2F07%2F30%2Fbirdge-pattern%2F</url>
      <content type="text"><![CDATA[桥接模式（bridge pattern）桥接模式（bridge pattern）：属于对象的结构型模式。将抽象部分与它的实现部分分离，使它们都可以独立地变化。 桥接模式UML图 由图可看出，系统包含了两个等级结构 由抽象化角色和被提炼的抽象化角色组成的抽象化等级结构 由实现化角色和两个具体的实现化角色组成的实现化等级结构 桥接模式涉及的角色抽象化（Abstraction）角色：抽象化给出的定义，并保存一个对实现化对象的引用。被提炼的抽象化（RefineAbstraction）角色：扩展抽象化角色，改变和修正父类对抽象化的定义。实现化（Implementor）角色：这个角色给出实现化角色的接口，但不给出具体的实现。具体实现化（ConcreteImplementor）角色：这个角色给出实现化角色接口的具体实现。 示例代码实现化抽象类 Implementor 123456789101112131415package com.example.bridge;/** * 桥接模式：实现化抽象类 * * @author pengdh * @date: 2017-07-30 23:32 */public abstract class Implementor &#123; /** * 实现抽象部分需要的某些具体功能 */ public abstract void operationImpl();&#125; 具体实现 A 类 ImplementorA 123456789101112131415package com.example.bridge;/** * 桥接模式：具体实现 A 类 * * @author pengdh * @date: 2017-07-30 23:41 */public class ImplementorA extends Implementor &#123; @Override public void operationImpl() &#123; System.out.println("具体实现 A 方法执行！"); &#125;&#125; 具体实现 B 类 ImplementorB 123456789101112131415package com.example.bridge;/** * 桥接模式：具体实现 B 类 * * @author pengdh * @date: 2017-07-30 23:42 */public class ImplementorB extends Implementor &#123; @Override public void operationImpl() &#123; System.out.println("具体实现 B 方法执行！"); &#125;&#125; 抽象化类 Abstraction 123456789101112131415161718package com.example.bridge;/** * 桥接模式：抽象化类 * * @author pengdh * @date: 2017-07-30 23:34 */public abstract class Abstraction &#123; protected Implementor impl; protected Abstraction(Implementor impl) &#123; this.impl = impl; &#125; public abstract void operation();&#125; 被提炼的抽象化类 RefinedAbstraction 12345678910111213141516171819package com.example.bridge;/** * 桥接模式：被提炼的抽象化类 * * @author pengdh * @date: 2017-07-30 23:36 */public class RefinedAbstraction extends Abstraction &#123; protected RefinedAbstraction(Implementor impl) &#123; super(impl); &#125; @Override public void operation() &#123; impl.operationImpl(); &#125;&#125; 客户端测试类 BridgePatternTest 1234567891011121314151617package com.example.bridge;/** * 桥接模式：客户端测试类 * * @author pengdh * @date: 2017-07-30 23:43 */public class BridgePatternTest &#123; public static void main(String[] args) &#123; Abstraction ab1 = new RefinedAbstraction(new ImplementorA()); ab1.operation(); Abstraction ab2 = new RefinedAbstraction(new ImplementorB()); ab2.operation(); &#125;&#125; 桥梁模式的优点 将抽象部分与它的实现部分分离 桥梁模式分离了抽象部分和实现部分，即实现系统可能有多种角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。 更好的扩展性 桥梁模式更好的利用了合成/聚合复用原则，使得抽象部分和实现部分可以分别独立地扩展，而不会相互影响，从而大大提高了系统的可扩展性。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十八）：单例模式]]></title>
      <url>%2F2017%2F07%2F30%2Fsingleton-pattern%2F</url>
      <content type="text"><![CDATA[单例模式（singleton pattern）单例模式（singleton pattern）：属于对象的创建型模式。保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式UML图 单例模式特点 单例类只能实例化一次。 单例类需要自己创建自己的唯一实例。 单例类需要提供一个给其它对象访问该唯一实例的方法。 示例代码饿汉式单例模式123456789101112131415161718192021222324package com.example.singletonPattern;/** * 单例模式：饿汉式 * * @author pengdh * @date: 2017-07-30 1:58 */public class EagerSingleton &#123; private static EagerSingleton instance = new EagerSingleton(); /** * 私有构造器 */ private EagerSingleton()&#123;&#125; /** * 静态工厂方法，获取全局唯一实例 * @return */ public static EagerSingleton getInstance () &#123; return instance; &#125;&#125; 如上示例中，当类第一次加载时就会初始化静态变量 instance ，此时就会调用类的私有构造器，这时就创建出了单例类的唯一实例。饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。 懒汉式单例模式123456789101112131415161718192021222324252627282930313233343536package com.example.singletonPattern;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 单例模式：懒汉式 * * @author pengdh * @date: 2017-07-30 2:08 */public class LazySingleton &#123; private static LazySingleton instance = null; /** * 私有构造器 */ private LazySingleton() &#123;&#125; /** * 静态工厂方法，获取全局唯一实例 * @return */ public static LazySingleton getInstance() &#123; Lock lock = new ReentrantLock(); lock.lock(); try &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; &#125; finally &#123; lock.unlock(); &#125; return instance; &#125;&#125; 如上示例中，当单例类加载时不会立刻创建对象的实例，而是在调用类的静态工厂方法时才创建对象的唯一实例，我们在获取实例的静态方法中使用了锁，这样做的目的是防止在多线程环境下多个对象同时调用静态工厂方法时出现并发问题。懒汉式是典型的时间换空间,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。 双重检查加锁1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.singletonPattern;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 单例模式：双重检查加锁 * * @author pengdh * @date: 2017-07-30 2:36 */public class DoubleCheckSingleton &#123; private volatile static DoubleCheckSingleton instance = null; /** * 私有构造器 */ private DoubleCheckSingleton() &#123;&#125; /** * 静态工厂方法，获取全局唯一实例 * @return */ public static DoubleCheckSingleton getInstance() &#123; // 先检查实例是否存在，如果不存在才进入下面的同步块 if (instance == null) &#123; // 加锁，线程安全的创建实例 Lock lock = new ReentrantLock(); lock.lock(); try &#123; // 再次检查实例是否存在，如果不存在才真正的创建实例 if (instance == null) &#123; instance = new DoubleCheckSingleton(); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; return instance; &#125;&#125; 如上示例使用了“双重检查加锁”的方式实现，既实现线程安全，又能够使性能不受很大的影响。所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。 Lazy initialization holder class模式1234567891011121314151617181920212223242526272829303132333435package com.example.singletonPattern;/** * 单例模式：Lazy initialization holder class模式 * * @author pengdh * @date: 2017-07-30 2:46 */public class Singleton &#123; /** * 私有构造器 */ private Singleton() &#123; &#125; /** * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例 * 没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。 */ private static class SingletonHolder &#123; /** * 静态初始化器，由JVM来保证线程安全 */ private static Singleton instance = new Singleton(); &#125; /** * 静态工厂方法，获取全局唯一实例 */ public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125;&#125; 如上示例中，当getInstance方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致 SingletonHolder 类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建 LazyHolderSingleton 的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。 单例和枚举123456789101112131415161718192021package com.example.singletonPattern;/** * 单例模式：使用枚举来实现单例模式 * * @author pengdh * @date: 2017-07-30 2:58 */public enum SingletonEnum &#123; /** * 定义一个枚举的元素，它就代表了 SingletonEnum 的一个实例。 */ uniqueInstance; /** * 单例可以有自己的操作 */ public void singletonOperation() &#123; // 功能实现 &#125;&#125; 使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 客户端测试类12345678910111213141516171819202122232425262728293031323334package com.example.singletonPattern;/** * 单例模式：客户端测试类 * * @author pengdh * @date: 2017-07-30 3:20 */public class SingletonTest &#123; public static void main(String[] args) &#123; EagerSingleton eager1 = EagerSingleton.getInstance(); EagerSingleton eager2 = EagerSingleton.getInstance(); LazySingleton lazy1 = LazySingleton.getInstance(); LazySingleton lazy2 = LazySingleton.getInstance(); DoubleCheckSingleton double1 = DoubleCheckSingleton.getInstance(); DoubleCheckSingleton double2 = DoubleCheckSingleton.getInstance(); Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); if (eager1 == eager2) &#123; System.out.println("\"饿汉式单例模式\" 的两个对象是相等的！"); &#125; if (lazy1 == lazy2) &#123; System.out.println("\"懒汉式单例模式\" 的两个对象是相等的！"); &#125; if (double1 == double2) &#123; System.out.println("\"双重检查加锁模式单例模式\" 的两个对象是相等的！"); &#125; if (s1 == s2) &#123; System.out.println("\"Lazy initialization holder class模式单例模式\" 的两个对象是相等的！"); &#125; &#125;&#125; 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十七）：迭代器模式]]></title>
      <url>%2F2017%2F07%2F24%2Fiterator-pattern%2F</url>
      <content type="text"><![CDATA[迭代器模式（iterator pattern）迭代器模式（iterator pattern）：属于对象的行为模式。提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。 迭代器模式UML图 迭代器模式涉及的角色抽象迭代器（Iterator）角色：用于定义得到开始对象、得到下一个对象、判断是否到结尾、当前对象等抽象方法，统一接口。具体迭代器（ConcreteIterator）角色：继承 Iterator，实现开始、下一个、是否结尾、当前对象等方法。抽象聚集（Aggregate）角色：创建迭代器(Iterator)对象的。具体聚集（ConcreteAggregate）角色：实现了创建迭代器(Iterator)对象，返回一个合适的具体迭代子实例。 示例代码迭代器抽象类 Iterator 123456789101112131415161718192021222324252627282930package com.example.iteratorPattern;/** * 迭代器模式：迭代器抽象类 * * @author pengdh * @date: 2017-07-24 23:10 */public abstract class Iterator &#123; /** * 移动到第一个元素 */ public abstract void first(); /** * 移动到下一个元素 */ public abstract void next(); /** * 判读是否为最后一个元素 */ public abstract boolean isDone(); /** * 返还当前元素 */ public abstract Object currentItem();&#125; 聚集抽象类 Aggregate 123456789101112131415package com.example.iteratorPattern;/** * 迭代器模式：聚集抽象类 * * @author pengdh * @date: 2017-07-24 23:17 */public abstract class Aggregate &#123; /** * 工厂方法，创建相应迭代器对象的 */ public abstract Iterator createIterator();&#125; 具体迭代器类 ConcreteIterator 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.example.iteratorPattern;/** * 迭代器模式：具体迭代器类 * * @author pengdh * @date: 2017-07-24 23:16 */public class ConcreteIterator extends Iterator &#123; //持有被迭代的具体的聚合对象 private ConcreteAggregate agg; //内部索引，记录当前迭代到的索引位置 private int index = 0; //记录当前聚集对象的大小 private int size = 0; public ConcreteIterator(ConcreteAggregate agg) &#123; this.agg = agg; this.size = agg.size(); index = 0; &#125; @Override public void first() &#123; index = 0; &#125; @Override public void next() &#123; if (index &lt; size) &#123; index++; &#125; &#125; @Override public boolean isDone() &#123; return (index &gt;= size); &#125; @Override public Object currentItem() &#123; return agg.getElement(index); &#125;&#125; 具体聚集类 ConcreteAggregate 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.iteratorPattern;/** * 迭代器模式：具体聚集类 * * @author pengdh * @date: 2017-07-24 23:20 */public class ConcreteAggregate extends Aggregate &#123; private Object[] objArray = null; /** * 构造方法，传入聚合对象的具体内容 */ public ConcreteAggregate(Object[] objArray) &#123; this.objArray = objArray; &#125; @Override public Iterator createIterator() &#123; return new ConcreteIterator(this); &#125; /** * 取值方法：向外界提供聚集元素 */ public Object getElement(int index) &#123; if (index &lt; objArray.length) &#123; return objArray[index]; &#125; else &#123; return null; &#125; &#125; /** * 取值方法：向外界提供聚集的大小 */ public int size() &#123; return objArray.length; &#125;&#125; 客户端测试类 IteratorPatternTest 12345678910111213141516171819202122package com.example.iteratorPattern;/** * 迭代器模式：客户端测试类 * * @author pengdh * @date: 2017-07-24 23:26 */public class IteratorPatternTest &#123; public static void main(String[] args) &#123; Object[] objArray = &#123;"One", "Two", "Three", "Four", "Five", "Six"&#125;; //创建聚合对象 Aggregate agg = new ConcreteAggregate(objArray); //循环输出聚合对象中的值 Iterator it = agg.createIterator(); while (!it.isDone()) &#123; System.out.println(it.currentItem()); it.next(); &#125; &#125;&#125; 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十六）：组合模式]]></title>
      <url>%2F2017%2F07%2F23%2Fcomposite-pattern%2F</url>
      <content type="text"><![CDATA[组合模式（composite pattern）组合模式（composite pattern）：属于对象的结构型模式。将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 组合模式UML图 组合模式涉及的角色抽象构件（Component）角色：组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理 Component 的子不部件树叶构件（Leaf）角色：在组合中表示叶节点对象，叶节点没有子节点树枝构件（Composite）角色：定义有枝节点行为，用来存储子部件，在 Component 接口中实现与子部件有关的操作，比如 增加 add 和删除 remove 组合模式的实现方式 透明方式 要求在 Component 中申明所有的管理方法，如： add 和 remove 方法，所有实现 Component 类的子类都实现了这些管理方法。这样做的好处是无论是树叶节点还是树枝节点对于外界是没有区别的，它们具备完全一致的行为接口。但问题也很明显，因为 树叶节点（Leaf）本身并不具备管理方法的功能，所以实现它是没有意义的。 安全方式 也就是在 Component 类中不去声明 add 和 remove 方法，那么子类的 Leaf 也就不需要去是实现它，而是在 Composite 类声明所有用来管理子类的对象的方法，这样做就不会出现透明方式的问题，不过由于不透明，所以树叶和树枝类将不具有相同的接口，客户端调用需要作出相应的判断，带来了不变。 在组成模式中，建议多采用透明方式 示例代码抽象构建类 Component 123456789101112131415161718192021222324252627282930313233package com.example.compositePattern;/** * 组合模式：抽象构建类 * * @author pengdh * @date: 2017-07-23 18:52 */public abstract class Component &#123; protected String name; public Component(String name) &#123; this.name = name; &#125; /** * 添加一个子部件对象 * @param c */ public abstract void add(Component c); /** * 删除一个子部件对象 * @param c */ public abstract void remove(Component c); /** * 显示目录树 * @param depth */ public abstract void display(String depth);&#125; 树叶构件类 Leaf 1234567891011121314151617181920212223242526272829package com.example.compositePattern;/** * 组合模式：树叶构件类 * * @author pengdh * @date: 2017-07-23 18:59 */public class Leaf extends Component &#123; public Leaf(String name) &#123; super(name); &#125; @Override public void add(Component c) &#123; return; &#125; @Override public void remove(Component c) &#123; return; &#125; @Override public void display(String depth) &#123; System.out.println(depth + " " + name); &#125;&#125; 树枝构件类 Composite 1234567891011121314151617181920212223242526272829303132333435363738package com.example.compositePattern;import java.util.ArrayList;import java.util.List;/** * 组合模式：树枝构件类 * * @author pengdh * @date: 2017-07-23 19:10 */public class Composite extends Component &#123; private List&lt;Component&gt; childrenComopnents = new ArrayList&lt;Component&gt;(); public Composite(String name) &#123; super(name); &#125; @Override public void add(Component c) &#123; childrenComopnents.add(c); &#125; @Override public void remove(Component c) &#123; childrenComopnents.remove(c); &#125; @Override public void display(String depth) &#123; System.out.println(depth + " " + name); depth += "+"; for (Component component : childrenComopnents) &#123; component.display(depth); &#125; &#125;&#125; 客户端测试类 TestCompositePattern 12345678910111213141516171819202122232425262728293031323334353637383940package com.example.compositePattern;/** * 组合模式：客户端测试类 * * @author pengdh * @date: 2017-07-23 19:16 */public class TestCompositePattern &#123; public static void main(String[] args) &#123; // 添加根节点 Composite root = new Composite("root"); // 根节点上添加叶子节点 root.add(new Leaf("Leaf A")); root.add(new Leaf("Leaf B")); // 添加树枝节点 Composite comp = new Composite("Composite X"); // 树枝节点上添加叶子节点 comp.add(new Leaf("Leaf XA")); comp.add(new Leaf("Leaf XB")); // 将树枝节点添加到根节点 root.add(comp); Composite comp2 = new Composite("Composite XY"); comp2.add(new Leaf("Leaf XYA")); comp2.add(new Leaf("Leaf XYB")); root.add(comp2); root.add(new Leaf("Leaf C")); Leaf leaf = new Leaf("D"); root.add(leaf); root.remove(leaf); root.display("+"); &#125;&#125; 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十五）：备忘录模式]]></title>
      <url>%2F2017%2F07%2F22%2Fmemento-pattern%2F</url>
      <content type="text"><![CDATA[备忘录模式（memento pattern）备忘录模式（memento pattern）：属于对象的行为模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就将该对象恢复到原乡保存的状态。 备忘录模式UML图 备忘录模式涉及的角色发起人（Originator）角色：负责创建一个含有当前的内部状态的备忘录对象。并可使用备忘录恢复内部状态。备忘录角色（Memento）角色：负责存储 Originator 对象的内部状态，并可防止 Originator 以外的其它对象访问备忘录 Memento。备忘录包含两个等效的接口： 窄接口：管理者（Caretaker）对象只能看到备忘录的窄接口（narrow interface），它只能将备忘录传递给其它对象。 宽接口：发起人（Originator）能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。 管理者角色（Caretaker）角色：负责保存好备忘录对象 Memento，不能对备忘录的内容进行操作或检查。 示例代码发起人类 Originator 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.mementoPattern;/** * 备忘录模式：发起人类 * * @author pengdh * @date: 2017-07-22 20:02 */public class Originator &#123; private String state; /** * 创建备忘录，将当前需要保存的信息保存。 * * @return 一个新的备忘录对象 */ public Memento createMemento() &#123; return new Memento(state); &#125; /** * 恢复备忘录，将发起人对象恢复到备忘录对象所记载的状态 * @param memento */ public void restoreMemento(Memento memento) &#123; this.state = memento.getState(); &#125; /** * 显示数据 */ public void show() &#123; System.out.println("state：" + state); &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125;&#125; 备忘录类 Memento 1234567891011121314151617181920212223package com.example.mementoPattern;/** * 备忘录模式：备忘录类 * * @author pengdh * @date: 2017-07-22 20:05 */public class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125;&#125; 管理者类 Caretaker 12345678910111213141516171819package com.example.mementoPattern;/** * 备忘录模式：管理者类 * * @author pengdh * @date: 2017-07-22 20:05 */public class Caretaker &#123; private Memento memento; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125;&#125; 客户端测试类 TestMementoPattern 12345678910111213141516171819202122232425262728package com.example.mementoPattern;/** * 备忘录模式：客户端测试类 * * @author pengdh * @date: 2017-07-22 20:15 */public class TestMementoPattern &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); // 改变发起人对象状态 originator.setState("On"); originator.show(); // 创建备忘录对象 Memento memento = originator.createMemento(); // 保存发起人状态 caretaker.setMemento(memento); // 改变发起人状态 originator.setState("Off"); originator.show(); // 恢复发起人状态 originator.restoreMemento(memento); originator.show(); &#125;&#125; 备忘录模式使用场景备忘录模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多熟悉中的一小部分时，Originator 可以根据保存的 Memento 信息还原到前一状态。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工作中一次使用 redis 存储操作数据的需求]]></title>
      <url>%2F2017%2F07%2F20%2Fwork-in-redis-use%2F</url>
      <content type="text"><![CDATA[好久没有更博了，这篇文章前段时间就应该记录的，无赖最近新项目加班太多，回到家已累成狗。实在不想动了，今天趁着要修改点东西回顾下之前处理逻辑记录下。其实感觉很多东西不用，不回顾很容易就忘记了。干我们这行更是这样。个人觉得经常记录写工作实践中遇到过的一些有意义的经历很有必要。说不定哪天就要你回来增加或者修改需求了呢。就像我现在这样的。这是一次工作中产品提的需求，自己的一次开发经历。 需求描述 需求是这样的：数据分析师分析提取了一些用户常听的歌曲基本信息，这些数据来自两个不同地方的不同类型的数据，大概分三种类型，用户偏好的一些歌手下的热门歌曲；用户偏好的一些分类标签（如：流行、伤感…）下的热门歌曲；还有一个是另外一个部门分析出来的用户常听的歌曲信息。产品要求我们将这些数据整合到一起：1、根据客户端需要的条数返回的数据不同类型要按不同比例响应，2、每种类型的歌曲要按歌曲热度排名显示。然后提供接口给其他平台调用获取用户偏好歌曲 top 信息。数据分析给的数据只包歌曲的基本信息，我们需要根据这些基本信息如歌曲id查询出歌曲的试听相关的完整信息。用户量大概是500w左右，每个月都会有更新。首先是给一个做微信网页推荐的平台展示并试听。因为数据比较大，而且要求我们接口响应速度要在1秒左右。因为分析送过来的数据本来就是属于热度数据，所以必须要所有数据都能快速提供到。 需求开发 我基于目前系统的架构，计划把 redis 作为数据存储，先把分析的数据整合同步到redis上，然后提供接口直接从 redis 取来提高响应速度。我们的 redis 是一个10台服务器的集群，5 master 和 5 slave。客户端使用 spring 和 jedis 整合的。 sping 配置文件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:util="http://www.springframework.org/schema/util" xmlns:cache="http://www.springframework.org/schema/cache" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd"&gt; &lt;!-- 加载配置属性文件 --&gt; &lt;context:property-placeholder ignore-unresolvable="true" location="classpath:redis/redis-cluster.properties" /&gt; &lt;context:component-scan base-package="com.xxx.xxx.redis"/&gt; &lt;bean name="genericObjectPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxWaitMillis" value="1000" /&gt; &lt;property name="maxTotal" value="1000"/&gt; &lt;property name="minIdle" value="8"/&gt; &lt;property name="maxIdle" value="100"/&gt; &lt;/bean&gt; &lt;bean id="jedisCluster" class="com.xxx.xxx.redis.cluster.JedisClusterFactory"&gt; &lt;property name="addressConfig"&gt; &lt;value&gt;classpath:redis/redis-cluster.properties&lt;/value&gt; &lt;/property&gt; &lt;property name="addressKeyPrefix" value="address" /&gt; &lt;property name="timeout" value="$&#123;TIMEOUT&#125;"/&gt; &lt;property name="maxAttempts" value="$&#123;MAXATTEMPTS&#125;" /&gt; &lt;property name="password" value="$&#123;PASSWORD&#125;"/&gt; &lt;property name="isNeedAuthentication" value="$&#123;IS_NEED_AUTHENTICATION&#125;"/&gt; &lt;property name="soTimeout" value="$&#123;SO_TIMEOUT&#125;"/&gt; &lt;property name="connectionTimeout" value="$&#123;CONNECTION_TIMEOUT&#125;"/&gt; &lt;property name="genericObjectPoolConfig" ref="genericObjectPoolConfig" /&gt; &lt;/bean&gt;&lt;/beans&gt; JedisClusterFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.xxx.xxx.redis.cluster;import java.util.Set;import java.util.HashSet;import java.util.Properties;import java.util.regex.Pattern;import redis.clients.jedis.HostAndPort;import redis.clients.jedis.JedisCluster;import org.springframework.core.io.Resource;import org.springframework.beans.factory.FactoryBean;import org.springframework.beans.factory.InitializingBean;import org.apache.commons.pool2.impl.GenericObjectPoolConfig;public class JedisClusterFactory implements FactoryBean&lt;JedisCluster&gt;, InitializingBean &#123; private Resource addressConfig; private String addressKeyPrefix ; private JedisCluster jedisCluster; private GenericObjectPoolConfig genericObjectPoolConfig; private String password; private boolean isNeedAuthentication; private Integer soTimeout; private Integer maxAttempts; private Integer connectionTimeout; private Integer timeout; private Pattern p = Pattern.compile("^.+[:]\\d&#123;1,5&#125;\\s*$"); @Override public JedisCluster getObject() throws Exception &#123; return jedisCluster; &#125; @Override public Class&lt;? extends JedisCluster&gt; getObjectType() &#123; return (this.jedisCluster != null ? this.jedisCluster.getClass() : JedisCluster.class); &#125; @Override public boolean isSingleton() &#123; return true; &#125; private Set&lt;HostAndPort&gt; parseHostAndPort() throws Exception &#123; try &#123; Properties prop = new Properties(); prop.load(this.addressConfig.getInputStream()); Set&lt;HostAndPort&gt; haps = new HashSet&lt;HostAndPort&gt;(); for (Object key : prop.keySet()) &#123; if (!((String) key).startsWith(addressKeyPrefix)) &#123; continue; &#125; String val = (String) prop.get(key); boolean isIpPort = p.matcher(val).matches(); if (!isIpPort) &#123; throw new IllegalArgumentException("ip 或 port 不合法"); &#125; String[] ipAndPort = val.split(":"); HostAndPort hap = new HostAndPort(ipAndPort[0], Integer.parseInt(ipAndPort[1])); haps.add(hap); &#125; return haps; &#125; catch (IllegalArgumentException ex) &#123; throw ex; &#125; catch (Exception ex) &#123; throw new Exception("解析 jedis 配置文件失败", ex); &#125; &#125; @Override public void afterPropertiesSet() throws Exception &#123; Set&lt;HostAndPort&gt; haps = this.parseHostAndPort(); if(isNeedAuthentication)&#123; jedisCluster = new JedisCluster(haps, connectionTimeout, soTimeout, maxAttempts, password, genericObjectPoolConfig); &#125;else&#123; jedisCluster = new JedisCluster(haps, timeout, maxAttempts,genericObjectPoolConfig); &#125; &#125; public void setAddressConfig(Resource addressConfig) &#123; this.addressConfig = addressConfig; &#125; public void setAddressKeyPrefix(String addressKeyPrefix) &#123; this.addressKeyPrefix = addressKeyPrefix; &#125; public void setGenericObjectPoolConfig(GenericObjectPoolConfig genericObjectPoolConfig) &#123; this.genericObjectPoolConfig = genericObjectPoolConfig; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setIsNeedAuthentication(boolean isNeedAuthentication) &#123; this.isNeedAuthentication = isNeedAuthentication; &#125; public void setSoTimeout(Integer soTimeout) &#123; this.soTimeout = soTimeout; &#125; public void setMaxAttempts(Integer maxAttempts) &#123; this.maxAttempts = maxAttempts; &#125; public void setConnectionTimeout(Integer connectionTimeout) &#123; this.connectionTimeout = connectionTimeout; &#125; public void setTimeout(Integer timeout) &#123; this.timeout = timeout; &#125; &#125; 客户端封装类 RedisCluster 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010package com.xxx.xxx.redis.cluster;import java.util.Map;import java.util.Set;import java.util.List;import javax.annotation.PostConstruct;import redis.clients.util.SafeEncoder;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.SortingParams;import org.springframework.stereotype.Service;import redis.clients.jedis.BinaryClient.LIST_POSITION;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;/** * * REDIS集群模式封装服务 * */@Service@Qualifier("default")public class RedisCluster &#123; @Autowired private JedisCluster jedisCluster; /**操作Key的方法*/ public Keys KEYS; /** 对存储结构为HashMap类型的操作 */ public Hash HASH; /** 对存储结构为Set(排序的)类型的操作 */ public SortSet SORTSET; /**对存储结构为String类型的操作*/ public Strings STRINGS; /** * 对存储结构为Lists类型的操作 */ public Lists LISTS; public Sets SETS; @PostConstruct public void init()&#123; SORTSET = new SortSet(); HASH = new Hash(); KEYS = new Keys(); STRINGS = new Strings(); LISTS = new Lists(); SETS = new Sets(); &#125; public class Hash &#123; /** * 从hash中删除指定的存储 * @param String * key * @param String * field 存储的名字 * @return 状态码，1成功，0失败 * */ public long hdel(String key, String field) &#123; long s = jedisCluster.hdel(key, field); return s; &#125; public long hdel(String key) &#123; long s = jedisCluster.del(key); return s; &#125; /** * 测试hash中指定的存储是否存在 * * @param String * key * @param String * field 存储的名字 * @return 1存在，0不存在 * */ public boolean hexists(String key, String field) &#123; boolean s = jedisCluster.hexists(key, field); return s; &#125; /** * 返回hash中指定存储位置的值 * * @param String * key * @param String * field 存储的名字 * @return 存储对应的值 * */ public String hget(String key, String field) &#123; String s = jedisCluster.hget(key, field); return s; &#125; /** * 以Map的形式返回hash中的存储和值 * * @param String * key * @return Map&lt;Strinig,String&gt; * */ public Map&lt;String, String&gt; hgetall(String key) &#123; Map&lt;String, String&gt; map = jedisCluster.hgetAll(key); return map; &#125; /** * 在指定的存储位置加上指定的数字，存储位置的值必须可转为数字类型 * * @param String * key * @param String * field 存储位置 * @param String * long value 要增加的值,可以是负数 * @return 增加指定数字后，存储位置的值 * */ public long hincrby(String key, String field, long value) &#123; long s = jedisCluster.hincrBy(key, field, value); return s; &#125; /** * 返回指定hash中的所有存储名字,类似Map中的keySet方法 * * @param String * key * @return Set&lt;String&gt; 存储名称的集合 * */ public Set&lt;String&gt; hkeys(String key) &#123; Set&lt;String&gt; set = jedisCluster.hkeys(key); return set; &#125; /** * 获取hash中存储的个数，类似Map中size方法 * * @param String * key * @return long 存储的个数 * */ public long hlen(String key) &#123; long len = jedisCluster.hlen(key); return len; &#125; /** * 根据多个key，获取对应的value，返回List,如果指定的key不存在,List对应位置为null * * @param String * key * @param String * ... fields 存储位置 * @return List&lt;String&gt; * */ public List&lt;String&gt; hmget(String key, String... fields) &#123; List&lt;String&gt; list = jedisCluster.hmget(key, fields); return list; &#125; /** * 添加对应关系，如果对应关系已存在，则覆盖 * * @param Strin * key * @param Map * &lt;String,String&gt; 对应关系 * @return 状态，成功返回OK * */ public String hmset(String key, Map&lt;String, String&gt; map) &#123; String s = jedisCluster.hmset(key, map); return s; &#125; /** * 添加一个对应关系 * * @param String * key * @param String * field * @param String * value * @return 状态码 1成功，0失败，field已存在将更新，也返回0 * **/ public long hset(String key, String field, String value) &#123; long s = jedisCluster.hset(key, field, value); return s; &#125; /** * 添加对应关系，只有在field不存在时才执行 * * @param String * key * @param String * field * @param String * value * @return 状态码 1成功，0失败field已存 * **/ public long hsetnx(String key, String field, String value) &#123; long s = jedisCluster.hsetnx(key, field, value); return s; &#125; /** * 获取hash中value的集合 * * @param String * key * @return List&lt;String&gt; * */ public List&lt;String&gt; hvals(String key) &#123; List&lt;String&gt; list = jedisCluster.hvals(key); return list; &#125; &#125; public class SortSet&#123; /** * 向集合中增加一条记录,如果这个值已存在，这个值对应的权重将被置为新的权重 * @param String key * @param double score 权重 * @param String member 要加入的值， * @return 状态码 1成功，0已存在member的值 * */ public long zadd(String key,double score,String member)&#123; long s =jedisCluster.zadd(key, score, member); return s; &#125; /** * 获取集合中元素的数量 * @param String key * @return 如果返回0则集合不存在 * */ public long zcard(String key)&#123; long len= jedisCluster.zcard(key); return len; &#125; /** * 获取指定权重区间内集合的数量 * @param String key * @param double min 最小排序位置 * @param double max 最大排序位置 * */ public long zcount(String key,double min,double max)&#123; long len= jedisCluster.zcount(key, min, max); return len; &#125; /** * 获得set的长度 * @param key * @return */ public int zlength(String key)&#123; int len = 0; Set&lt;String&gt; set = zrange(key,0L,-1L); len = set.size(); return len; &#125; /** * 权重增加给定值，如果给定的member已存在 * @param String key * @param double score 要增的权重 * @param String member 要插入的值 * @return 增后的权重 * */ public double zincrby(String key,double score,String member)&#123; double s =jedisCluster.zincrby(key, score, member); return s; &#125; /** * 返回指定位置的集合元素,0为第一个元素，-1为最后一个元素 * @param String key * @param int start 开始位置(包含) * @param int end 结束位置(包含) * @return Set&lt;String&gt; * */ public Set&lt;String&gt; zrange(String key,long start,long end)&#123; Set&lt;String&gt; set= jedisCluster.zrange(key, start, end); return set; &#125; /** * 返回指定权重区间的元素集合 * @param String key * @param double min 上限权重 * @param double max 下限权重 * @return Set&lt;String&gt; * */ public Set&lt;String&gt; zrangeByScore(String key,double min,double max)&#123; Set&lt;String&gt; set= jedisCluster.zrangeByScore(key, min, max); return set; &#125; /** * 获取指定值在集合中的位置，集合排序从低到高 * @see zrevrank * @param String key * @param String member * @return long 位置 * */ public long zrank(String key,String member)&#123; long index= jedisCluster.zrank(key,member); return index; &#125; /** * 获取指定值在集合中的位置，集合排序从低到高 * @see zrank * @param String key * @param String member * @return long 位置 * */ public long zrevrank(String key,String member)&#123; long index= jedisCluster.zrevrank(key, member); return index; &#125; /** * 从集合中删除成员 * @param String key * @param String member * @return 返回1成功 * */ public long zrem(String key,String member)&#123; long s =jedisCluster.zrem(key, member); return s; &#125; /** * 删除 * @param key * @return */ public long zrem(String key)&#123; long s =jedisCluster.del(key); return s; &#125; /** * 删除给定位置区间的元素 * @param String key * @param int start 开始区间，从0开始(包含) * @param int end 结束区间,-1为最后一个元素(包含) * @return 删除的数量 * */ public long zremrangeByRank(String key,int start,int end)&#123; long s =jedisCluster.zremrangeByRank(key, start, end); return s; &#125; /** * 删除给定权重区间的元素 * @param String key * @param double min 下限权重(包含) * @param double max 上限权重(包含) * @return 删除的数量 * */ public long zremrangeByScore(String key,double min,double max)&#123; long s =jedisCluster.zremrangeByScore(key, min, max); return s; &#125; /** * 获取给定区间的元素，原始按照权重由高到低排序 * @param String key * @param int start * @param int end * @return Set&lt;String&gt; * */ public Set&lt;String&gt; zrevrange(String key,int start,int end)&#123; Set&lt;String&gt; set= jedisCluster.zrevrange(key,start,end); return set; &#125; /** * 获取给定值在集合中的权重 * @param String key * @param memeber * @return double 权重 * */ public double zscore(String key,String memebr)&#123; Double score= jedisCluster.zscore(key,memebr); if(score!=null) return score; return 0; &#125; &#125; public class Keys&#123; /** * 更改key,仅当新key不存在时才执行 * @param String oldkey * @param String newkey * @return 状态码 * */ @SuppressWarnings("deprecation") public String flushAll()&#123; String stata=jedisCluster.flushAll(); return stata; &#125; /** * 设置key的过期时间，以秒为单位 * @param String key * @param 时间,已秒为单位 * @return 影响的记录数 * */ public long expired(String key,int seconds)&#123; long count =jedisCluster.expire(key, seconds); return count; &#125; /** * 设置key的过期时间,它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00，格里高利历）的偏移量。 * @param String key * @param 时间,已秒为单位 * @return 影响的记录数 * */ public long expireAt(String key,long timestamp)&#123; long count =jedisCluster.expireAt(key, timestamp); return count; &#125; /** * 查询key的过期时间 * @param String key * @return 以秒为单位的时间表示 * */ public long ttl(String key)&#123; long len=jedisCluster.ttl(key); return len; &#125; /** * 取消对key过期时间的设置 *@param key *@return 影响的记录数 * */ public long persist(String key)&#123; long count =jedisCluster.persist(key); return count; &#125; /** * 删除keys对应的记录,可以是多个key * @param String... keys * @return 删除的记录数 * */ public long del(String... keys)&#123; long delCount=0; for(String key:keys)&#123; delCount += jedisCluster.del(key); &#125; return delCount; &#125; /** * 判断key是否存在 * @param String key * @return boolean * */ public boolean exists(String key)&#123; boolean isExist=jedisCluster.exists(key); return isExist; &#125; /** * 对List,Set,SortSet进行排序,如果集合数据较大应避免使用这个方法 * @param String key * @return List&lt;String&gt; 集合的全部记录 * **/ public List&lt;String&gt; sort(String key)&#123; List&lt;String&gt; list=jedisCluster.sort(key); return list; &#125; /** * 对List,Set,SortSet进行排序或limit * @param String key * @param SortingParams parame 定义排序类型或limit的起止位置. * @return List&lt;String&gt; 全部或部分记录 * **/ public List&lt;String&gt; sort(String key,SortingParams parame)&#123; List&lt;String&gt; list=jedisCluster.sort(key, parame); return list; &#125; /** * 返回指定key存储的类型 * @param String key * @return String string|list|set|zset|hash * **/ public String type(String key)&#123; String type=jedisCluster.type(key); return type; &#125; &#125; public class Strings&#123; /** * 根据key获取记录 * @param String key * @return 值 * */ public String get(String key)&#123; String value= jedisCluster.get(key); return value; &#125; /** * 添加有过期时间的记录 * @param String key * @param int seconds 过期时间，以秒为单位 * @param String value * @return String 操作状态 * */ public String setEx(String key,int seconds,String value)&#123; String str =jedisCluster.setex(key, seconds, value); return str; &#125; /** * 添加一条记录，仅当给定的key不存在时才插入 * @param String key * @param String value * @return long 状态码，1插入成功且key不存在，0未插入，key存在 * */ public long setnx(String key,String value)&#123; long str =jedisCluster.setnx(key, value); return str; &#125; /** * 添加记录,如果记录已存在将覆盖原有的value * @param String key * @param String value * @return 状态码 * */ public String set(String key,String value)&#123; return jedisCluster.set(key, value); &#125; /** * 从指定位置开始插入数据，插入的数据会覆盖指定位置以后的数据&lt;br/&gt; * 例:String str1="123456789";&lt;br/&gt; * 对str1操作后setRange(key,4,0000)，str1="123400009"; * @param String key * @param long offset * @param String value * @return long value的长度 * */ public long setRange(String key,long offset,String value)&#123; long len =jedisCluster.setrange(key, offset, value); return len; &#125; /** * 在指定的key中追加value * @param String key * @param String value * @return long 追加后value的长度 * **/ public long append(String key,String value)&#123; long len =jedisCluster.append(key, value); return len; &#125; /** * 将key对应的value减去指定的值，只有value可以转为数字时该方法才可用 * @param String key * @param long number 要减去的值 * @return long 减指定值后的值 * */ public long decrBy(String key,long number)&#123; long len =jedisCluster.decrBy(key,number); return len; &#125; /** * &lt;b&gt;可以作为获取唯一id的方法&lt;/b&gt;&lt;br/&gt; * 将key对应的value加上指定的值，只有value可以转为数字时该方法才可用 * @param String key * @param long number 要减去的值 * @return long 相加后的值 * */ public long incrBy(String key,long number)&#123; long len =jedisCluster.incrBy(key,number); return len; &#125; /** * 对指定key对应的value进行截取 * @param String key * @param long startOffset 开始位置(包含) * @param long endOffset 结束位置(包含) * @return String 截取的值 * */ public String getrange(String key,long startOffset,long endOffset)&#123; String value= jedisCluster.getrange(key, startOffset, endOffset); return value; &#125; /** * 获取并设置指定key对应的value&lt;br/&gt; * 如果key存在返回之前的value,否则返回null * @param String key * @param String value * @return String 原始value或null * */ public String getSet(String key,String value)&#123; String str =jedisCluster.getSet(key, value); return str; &#125; /** * 获取key对应的值的长度 * @param String key * @return value值得长度 * */ public long strlen(String key)&#123; long len =jedisCluster.strlen(key); return len; &#125; &#125; public class Lists&#123; /** * List长度 * @param String key * @return 长度 * */ public long llen(String key)&#123; return llen(SafeEncoder.encode(key)); &#125; /** * List长度 * @param byte[] key * @return 长度 * */ public long llen(byte[] key)&#123; long count= jedisCluster.llen(key); return count; &#125; /** * 覆盖操作,将覆盖List中指定位置的值 * @param byte[] key * @param int index 位置 * @param byte[] value 值 * @return 状态码 * */ public String lset(byte[] key,int index,byte[] value)&#123; String status=jedisCluster.lset(key, index, value); return status; &#125; /** * 覆盖操作,将覆盖List中指定位置的值 * @param key * @param int index 位置 * @param String value 值 * @return 状态码 * */ public String lset(String key,int index,String value)&#123; return lset(SafeEncoder.encode(key),index,SafeEncoder.encode(value)); &#125; /** * 在value的相对位置插入记录 * @param key * @param LIST_POSITION 前面插入或后面插入 * @param String pivot 相对位置的内容 * @param String value 插入的内容 * @return 记录总数 * */ public long linsert(String key,LIST_POSITION where,String pivot,String value)&#123; return linsert(SafeEncoder.encode(key),where,SafeEncoder.encode(pivot),SafeEncoder.encode(value)); &#125; /** * 在指定位置插入记录 * @param String key * @param LIST_POSITION 前面插入或后面插入 * @param byte[] pivot 相对位置的内容 * @param byte[] value 插入的内容 * @return 记录总数 * */ public long linsert(byte[] key,LIST_POSITION where,byte[] pivot,byte[] value)&#123; long count=jedisCluster.linsert(key, where, pivot, value); return count; &#125; /** * 获取List中指定位置的值 * @param String key * @param int index 位置 * @return 值 * **/ public String lindex(String key,int index)&#123; return SafeEncoder.encode(lindex(SafeEncoder.encode(key),index)); &#125; /** * 获取List中指定位置的值 * @param byte[] key * @param int index 位置 * @return 值 * **/ public byte[] lindex(byte[] key,int index)&#123; byte[] value=jedisCluster.lindex(key, index); return value; &#125; /** * 将List中的第一条记录移出List * @param String key * @return 移出的记录 * */ public String lpop(String key)&#123; return SafeEncoder.encode(lpop(SafeEncoder.encode(key))); &#125; /** * 将List中的第一条记录移出List * @param byte[] key * @return 移出的记录 * */ public byte[] lpop(byte[] key)&#123; byte[] value=jedisCluster.lpop(key); return value; &#125; /** * 将List中最后第一条记录移出List * @param byte[] key * @return 移出的记录 * */ public String rpop(String key)&#123; String value=jedisCluster.rpop(key); return value; &#125; /** * 向List尾部追加记录 * @param String key * @param String value * @return 记录总数 * */ public long lpush(String key,String value)&#123; return lpush(SafeEncoder.encode(key),SafeEncoder.encode(value)); &#125; /** * 向List头部追加记录 * @param String key * @param String value * @return 记录总数 * */ public long rpush(String key,String value)&#123; long count=jedisCluster.rpush(key, value); return count; &#125; /** * 向List中追加记录 * @param byte[] key * @param byte[] value * @return 记录总数 * */ public long lpush(byte[] key,byte[] value)&#123; long count=jedisCluster.lpush(key, value); return count; &#125; /** * 获取指定范围的记录，可以做为分页使用 * @param String key * @param long start * @param long end * @return List * */ public List&lt;String&gt; lrange(String key,long start,long end)&#123; List&lt;String&gt; list=jedisCluster.lrange(key, start,end); return list; &#125; /** * 获取指定范围的记录，可以做为分页使用 * @param byte[] key * @param int start * @param int end 如果为负数，则尾部开始计算 * @return List * */ public List&lt;byte[]&gt; lrange(byte[] key,int start,int end)&#123; List&lt;byte[]&gt; list=jedisCluster.lrange(key, start,end); return list; &#125; /** * 删除List中c条记录，被删除的记录值为value * @param byte[] key * @param int c 要删除的数量，如果为负数则从List的尾部检查并删除符合的记录 * @param byte[] value 要匹配的值 * @return 删除后的List中的记录数 * */ public long lrem(byte[] key,int c,byte[] value)&#123; long count=jedisCluster.lrem(key, c,value); return count; &#125; /** * 删除List中c条记录，被删除的记录值为value * @param String key * @param int c 要删除的数量，如果为负数则从List的尾部检查并删除符合的记录 * @param String value 要匹配的值 * @return 删除后的List中的记录数 * */ public long lrem(String key,int c,String value)&#123; return lrem(SafeEncoder.encode(key),c,SafeEncoder.encode(value)); &#125; /** * 算是删除吧，只保留start与end之间的记录 * @param byte[] key * @param int start 记录的开始位置(0表示第一条记录) * @param int end 记录的结束位置（如果为-1则表示最后一个，-2，-3以此类推） * @return 执行状态码 * */ public String ltrim(byte[] key,int start,int end)&#123; String str=jedisCluster.ltrim(key, start, end); return str; &#125; /** * 算是删除吧，只保留start与end之间的记录 * @param String key * @param int start 记录的开始位置(0表示第一条记录) * @param int end 记录的结束位置（如果为-1则表示最后一个，-2，-3以此类推） * @return 执行状态码 * */ public String ltrim(String key,int start,int end)&#123; return ltrim(SafeEncoder.encode(key),start,end); &#125; &#125; public class Sets&#123; /** * 向Set添加一条记录，如果member已存在返回0,否则返回1 * @param String key * @param String member * @return 操作码,0或1 * */ public long sadd(String key,String member)&#123; long s =jedisCluster.sadd(key, member); return s; &#125; /** * 获取给定key中元素个数 * @param String key * @return 元素个数 * */ public long scard(String key)&#123; long len=jedisCluster.scard(key); return len; &#125; /** * 返回从第一组和所有的给定集合之间的差异的成员 * @param String... keys * @return 差异的成员集合 * */ public Set&lt;String&gt; sdiff(String...keys)&#123; Set&lt;String&gt; set =jedisCluster.sdiff(keys); return set; &#125; /** * 这个命令等于sdiff,但返回的不是结果集,而是将结果集存储在新的集合中，如果目标已存在，则覆盖。 * @param String newkey 新结果集的key * @param String... keys 比较的集合 * @return 新集合中的记录数 * **/ public long sdiffstore(String newkey,String...keys)&#123; long s =jedisCluster.sdiffstore(newkey, keys); return s; &#125; /** * 返回给定集合交集的成员,如果其中一个集合为不存在或为空，则返回空Set * @param String... keys * @return 交集成员的集合 * **/ public Set&lt;String&gt; sinter(String...keys)&#123; Set&lt;String&gt; set =jedisCluster.sinter(keys); return set; &#125; /** * 这个命令等于sinter,但返回的不是结果集,而是将结果集存储在新的集合中，如果目标已存在，则覆盖。 * @param String newkey 新结果集的key * @param String... keys 比较的集合 * @return 新集合中的记录数 * **/ public long sinterstore(String newkey,String...keys)&#123; long s =jedisCluster.sinterstore(newkey, keys); return s; &#125; /** * 确定一个给定的值是否存在 * @param String key * @param String member 要判断的值 * @return 存在返回1，不存在返回0 * **/ public boolean sismember(String key,String member)&#123; boolean s= jedisCluster.sismember(key, member); return s; &#125; /** * 返回集合中的所有成员 * @param String key * @return 成员集合 * */ public Set&lt;String&gt; smembers(String key)&#123; Set&lt;String&gt; set= jedisCluster.smembers(key); return set; &#125; /** * 将成员从源集合移出放入目标集合 * &lt;br/&gt;如果源集合不存在或不包哈指定成员，不进行任何操作，返回0&lt;br/&gt; * 否则该成员从源集合上删除，并添加到目标集合，如果目标集合中成员已存在，则只在源集合进行删除 * @param String srckey 源集合 * @param String dstkey 目标集合 * @param String member 源集合中的成员 * @return 状态码，1成功，0失败 * */ public long smove(String srckey,String dstkey,String member)&#123; long s =jedisCluster.smove(srckey, dstkey, member); return s; &#125; /** * 从集合中删除成员 * @param String key * @return 被删除的成员 * */ public String spop(String key)&#123; String s =jedisCluster.spop(key); return s; &#125; /** * 从集合中删除指定成员 * @param String key * @param String member 要删除的成员 * @return 状态码，成功返回1，成员不存在返回0 * */ public long srem(String key,String member)&#123; long s =jedisCluster.srem(key,member); return s; &#125; /** * 合并多个集合并返回合并后的结果，合并后的结果集合并不保存&lt;br/&gt; * @param String... keys * @return 合并后的结果集合 * @see sunionstore * */ public Set&lt;String&gt; sunion(String...keys)&#123; Set&lt;String&gt; set =jedisCluster.sunion(keys); return set; &#125; /** * 合并多个集合并将合并后的结果集保存在指定的新集合中，如果新集合已经存在则覆盖 * @param String newkey 新集合的key * @param String... keys 要合并的集合 * **/ public long sunionstore(String newkey,String...keys)&#123; long s =jedisCluster.sunionstore(newkey, keys); return s; &#125; &#125; &#125; 封装的 redis 客户端很容易操作，只要知道 redis 操作命令和容易使用。 同步 redis 数据我使用的是 spring 集成的定时任务，配置如下 123456789101112131415&lt;!-- 线程执行器配置，用于任务注册 --&gt; &lt;bean id="executor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt; &lt;!-- 核心线程数 --&gt; &lt;property name="corePoolSize" value="50" /&gt; &lt;!-- 最大线程数 --&gt; &lt;property name="maxPoolSize" value="100" /&gt; &lt;!-- 队列最大长度 &gt;=mainExecutor.maxSize --&gt; &lt;property name="queueCapacity" value="500" /&gt; &lt;!-- 线程池维护线程所允许的空闲时间 --&gt; &lt;!-- &lt;property name="keepAliveSeconds" value="300" /&gt; --&gt; &lt;!-- 线程池对拒绝任务(无线程可用)的处理策略 ThreadPoolExecutor.CallerRunsPolicy策略 ,调用者的线程会执行该任务,如果执行器已关闭,则丢弃. --&gt; &lt;property name="rejectedExecutionHandler"&gt; &lt;bean class="java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy" /&gt; &lt;/property&gt; &lt;/bean&gt; 业务处理根据需求描述，最好的方式是把每个用户对应的歌曲信息以用户手机号作为key，将整理成最终要响应的歌曲信息为值存入 redis，这样客户端调用时直接取出数据响应接口。我开始就是这样干的。很快接口开发出来了，但是很快我就又开始重做了。因为我开始只拿到很少用户数据。每个用户对应的歌曲信息也只有几十条。但是后来数据分析一下提取了一份全量数据，用户量是500多万。而且我们关联处理出来后，每个用户偏好的歌曲是几百首。nnd，算了下，每个用户的数据大概有 200kb 如果早这样的逻辑存储 md 得要至少 100G 内存，这下要命了。redis原来分配的是10g操作内存，同步数据的时候一会儿就满了。怎么办？冷静下来想想，用户数虽然多，但是有很多用户偏好的歌曲是相同的，而且歌曲根本不会有那么多，也就几十万的样子。灵感来了，现在需要将歌曲信息分离出来单独存储形成一个公共数据。并且我将歌曲信息使用 hash 结构存储。这样更节省空间。 存储歌曲信息操作 123456789101112131415161718192021222324252627282930313233343536/** * * FunName: addSongInfoToHash * @param songInfoNamespace * @Function: 添加歌曲信息到 hash * @param recommend 推荐歌曲信息 */ private void addSongInfoToHash(String songInfoNamespace, Recommend recommend) &#123; boolean exists = redisCluster.KEYS.exists(songInfoNamespace); if (!exists) &#123; ConcurrentMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;String, String&gt;(); if (ValidateParameterUtil.isNotEmpty(recommend.getSongId())) &#123; map.put("songId", recommend.getSongId()); &#125; if (ValidateParameterUtil.isNotEmpty(recommend.getSongName())) &#123; map.put("songName", recommend.getSongName()); &#125; if (ValidateParameterUtil.isNotEmpty(recommend.getSingerName())) &#123; map.put("singerName", recommend.getSingerName()); &#125; if (ValidateParameterUtil.isNotEmpty(recommend.getSingerPic())) &#123; map.put("singerPic", recommend.getSingerPic()); &#125; if (ValidateParameterUtil.isNotEmpty(recommend.getCopyrightId())) &#123; map.put("copyrightId", recommend.getCopyrightId()); &#125; if (ValidateParameterUtil.isNotEmpty(recommend.getMp3Audition())) &#123; map.put("mp3Audition", recommend.getMp3Audition()); &#125; if (ValidateParameterUtil.isNotEmpty(recommend.getHdAudition())) &#123; map.put("hdAudition", recommend.getHdAudition()); &#125; redisCluster.HASH.hmset(songInfoNamespace, map); &#125; &#125; 这下解决了歌曲信息的存储问题，随之是下一个问题，前面说到过，不同类型要按不同比例取并且要按照歌曲热度排名。例如，要为用户展示50首歌曲，要求取歌手类下面的歌曲 50% 也就是 歌手类下面排名靠前的 25首，然后标签下取 30% 也就是 前 15首，其它 20% 也就是 10首。这样的话，我们就不能在同步数据的时候直接将用户号码关联歌曲id，这样的话可以对歌曲排名但是区分不了比例。因为所有的歌曲都混在一起了就不知道歌曲是对应在哪个类型下的了。这样就需要我们在中间存一个转换对应关系，这就是用户偏好的类型信息了。我们将每个用户号码先喜好的歌曲分类存储上。 同步用户偏好的分类信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * * @ClassName:CachePreferenceRunnable * Function: 同步用户偏好信息定时任务 * @version * * @author pengdh * @date: 2017年6月2日 下午5:05:56 */private class CachePreferenceRunnable implements Runnable &#123; private Preference pre; public CachePreferenceRunnable(Preference pre) &#123; this.pre = pre; &#125; @Override public void run() &#123; ConcurrentMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;String, String&gt;(); String mobile = pre.getMobile(); String mobileMatchPreferNamespace = RecommendHelper.createMobileMatchPreferNamespace(mobile); if (ValidateParameterUtil.isNotEmpty(pre.getSingerName1())) &#123; map.put("singerName1", pre.getSingerName1()); &#125; if (ValidateParameterUtil.isNotEmpty(pre.getSingerName2())) &#123; map.put("singerName2", pre.getSingerName2()); &#125; if (ValidateParameterUtil.isNotEmpty(pre.getSingerName3())) &#123; map.put("singerName3", pre.getSingerName3()); &#125; if (ValidateParameterUtil.isNotEmpty(pre.getSingerName4())) &#123; map.put("singerName4", pre.getSingerName4()); &#125; if (ValidateParameterUtil.isNotEmpty(pre.getSingerName5())) &#123; map.put("singerName5", pre.getSingerName5()); &#125; if (ValidateParameterUtil.isNotEmpty(pre.getStyle())) &#123; map.put("style", pre.getStyle()); &#125; if (ValidateParameterUtil.isNotEmpty(pre.getEmotion())) &#123; map.put("emotion", pre.getEmotion()); &#125; if (ValidateParameterUtil.isNotEmpty(pre.getScene())) &#123; map.put("scene", pre.getScene()); &#125; if (!map.isEmpty()) &#123; redisCluster.HASH.hmset(mobileMatchPreferNamespace, map); logger.info("&gt;&gt;&gt;&gt;&gt;&gt; 添加号码：" + mobile + " 偏好信息完成。操作 set的key：" + mobileMatchPreferNamespace + " 包含的成员信息：" + redisCluster.HASH.hgetall(mobileMatchPreferNamespace)); manageAllMobileKeyToSet(mobileMatchPreferNamespace); &#125; &#125; 然后将每种歌曲分类下的歌曲 id 按照歌曲排名用有序集合（sorted set）的数据结构存储。 123456789101112/** * * FunName: addPreferMatchSongToZSet * @param prefer 偏好 * @Function: 添加偏好拥有歌曲到 zset * @param singerOwnSongNamespace zset 键名 * @param recommend 推荐歌曲信息 */ private void addPreferMatchSongToZSet(String prefer, String preferMatchSongNamespace, Recommend recommend) &#123; long result = redisCluster.SORTSET.zadd(preferMatchSongNamespace, Double.parseDouble(recommend.getSort()), recommend.getSongId()); logger.info("&gt;&gt;&gt;&gt;&gt;&gt; 将偏好：*" + prefer + "* 下的歌曲：" + recommend.getSongId() + " 添加到 zset，操作key： " + preferMatchSongNamespace + " 同步结果：" + result); &#125; 这样我们就可以既把数据分离，又可以找到对应关系了。客户端在调用接口的时候，先根据用户号码找到，号码下的歌曲分类，然后根据分类找到分类下的歌曲信息，最后根据客户端需要的条数按照不同类型对应的比例取数据返回。这里还有还有一个问题是不同类型下可能会存在同一首歌曲的情况，所以在取出数据之后还需要过滤下重复数据。 管理所有关联关系已经数据因为数据是每个月都需要进行更新的，所以为了方便清理数据，我们需要存储的所有数据都管理起来，因为数据存储在 redis，所以最好的办法就是把所有 key 管理清理，这样清理数据的时候只需用相同的命令就可以清理了。redisCluster.KEYS.del(namespace);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于 springMVC 的 RESTful HTTP API 实践（服务端）]]></title>
      <url>%2F2017%2F06%2F26%2FspringMVC-restful-api%2F</url>
      <content type="text"><![CDATA[理解 RESTREST（Representational State Transfer）,中文翻译叫“表述性状态转移”。是 Roy Thomas Fielding 在他2000年的博士论文中提出的。它与传统的 SOAP Web 服务区别在于，REST关注的是要处理的数据，而 SOAP 主要关注行为和处理。要理解好 REST，根据其首字母拆分出的英文更容易理解。表述性（Representational）:对于 REST 来说，我们网络上的一个个URI资源可以用各种形式来表述，例如：XML、JSON或者HTML等。状态（State）：REST 更关注资源的状态而不是对资源采取的行为。转移（Transfer）：在网络传输过程中，REST 使资源以某种表述性形式从一个应用转移到另一个应用（如从服务端转移到客户端）。 具体来说，REST 中存在行为，它的行为是通过 HTTP 表示操作的方法来定义的即：GET、POST、PUT、DELETE、PATCH；GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，PATCH用来更新资源。 基于 REST 这样的观点，我们需要避免使用 REST服务、REST Web服务 这样的称呼，这些称呼多少都带有一些强调行为的味道。 使用 RESTful 架构设计使用误区RESTful 架构：是基于 REST 思想的时下比较流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 在没有足够了解 REST 的时候，我们很容易错误的将其视为 “基于 URL 的 Web 服务”，即将 REST 和 SOAP 一样，是一种远程过程调用（remote procedure call，RPC）的机制。但是 REST 和 RPC 几乎没有任何关系，RPC 是面向服务的，而 REST 是面向资源的，强调描述应用程序的事物和名词。这样很容易导致的一个结果是我们在设计 RESTful API 时，在 URI 中使用动词。例如：GET /user/getUser/123。正确写法应该是 GET /user/123。 使用 springMVC 支持 RESTful在 spring 3.0 以后，spring 这对 springMVC 的一些增强功能对 RESTful 提供了良好的支持。在4.0后的版本中，spring 支持一下方式创建 REST 资源： 控制器可以处理所有的 HTTP 方法，包含几个主要的 REST 方法：GET、POST、PUT、DELETE、PATCH； 借助 @PathVariable 注解，控制器能够处理参数化的 URL（将变量输入作为 URL 的一部分）； 借助 spring 的视图解析器，资源能够以多种方式进行表述，包括将模型数据渲染为 XML、JSON、Atom、已经 RSS 的 View 实现； 可以使用 ContentNegotiatingViewResolver 来选择最适合客户端的表述； 借助 @ResponseBody 注解和各种 HttpMethodConverter 实现，能够替换基于视图的渲染方式； 类似地，@RequestBody 注解以及 HttpMethodConverter 实现可以将传入的 HTTP 数据转化为传入控制器处理方法的 Java 对象； 借助 RestTemplate ，spring 应用能够方便地使用 REST 资源。 创建 RESTful 控制器代码清单 12345678910111213141516171819202122232425262728package com.pengdh.controller;import com.pengdh.entity.EmployeeEntity;import com.pengdh.service.EmployeeService;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;/** * @author pengdh * @date: 2017-06-27 0:08 */@Controller@RequestMapping("/employs")public class EmployeeController &#123; @Autowired private EmployeeService empService; @GetMapping(value = "/list", produces = &#123; "application/json;charset=UTF-8" &#125;) public List&lt;EmployeeEntity&gt; employs(Integer offset,Integer limit) &#123; offset = offset == null ? 0 : offset; limit = limit == null ? 20 : limit; return empService.queryEmployList(offset,limit); &#125;&#125; 代码的大致过程是当客户端发起对 “/employs” 的 GET 请求时，将调用服务端的 employs 方法，服务端通过注入的 EmployeeService 获取到一个 EmployeeEntity 列表，并将列表以 JSON 的表述形式返回给客户端。 需要注意的是这里控制器本身并不关心资源如何表述。控制器以 Java 对象的方式来处理资源。控制器完成了它的工作以后，资源才会被转化成为适合客户端的形式。spring 提供了两种方法将资源的 java 表述形式转化为发送给客户端的表述形式： 内容协商（Content negotiation）：选择一个视图，它能够将模型渲染为呈现给客户端的表述形式； 消息转化器（Message conversion）：通过一个消息转换器将控制器所返回的对象转换为呈现给客户端的表述形式。 对于上述两种方式，第一种方式是通过 ContentNegotiatingViewResolver 作为 ViewResolver 的实现，主要是用于将资源渲染人类用户接口所需要的视图模型，如：HTML、JSP等也可以渲染。也可以针对不是人类客户端产生 JSON 或 XML，但是效果不是很理想，往往会产生一些不是客户端所需要的预期结果。如：客户端希望得到的响应可能是：{“name”:”zhangs”,”age”:”20”}。而模型是 key-value 组成的 map ，可能最终的响应是这样的：{“user”:{“name”:”zhangs”,”age”:”20”}}。基于内容协商的这些限制，这里我们主要讨论第二种方式：使用 Spring 的消息转换功能来生成资源表述。 使用 HTTP 消息转换器这是一种更为直接的方式，消息转换器能够将控制器产生的数据转换为服务于客户端的表述形式。常用的一些消息转换器如：Jackson 的 MappingJacksonHttpMessageConverter 实现 JSON 消息和 Java 对象的互相转换； JAXB 库的 Jaxb2RootElementHttpMessageConverter 实现 XML 和 Java 对象的相互转换等。 通过 @ResponseBody 注解实现响应体中返回资源状态。正常情况下，当处理方法返回 Java 对象时，这个对象会放在模型中并在视图中渲染使用。但是，如果使用了消息转换功能的话，我们需要告诉 Spring 跳过正常的模型/视图流程，并使用消息转换器。实现这种方式最简单的方式是在控制器的方法上添加 @ResponseBody 注解。如： 12345678@GetMapping(value = "/list", produces = &#123; "application/json;charset=UTF-8" &#125;)@ResponseBodypublic List&lt;EmployeeEntity&gt; employs(Integer offset,Integer limit) &#123; offset = offset == null ? 0 : offset; limit = limit == null ? 20 : limit; return empService.queryEmployList(offset,limit);&#125; 这里 @ResponseBody 注解会告知 Spring 将 List 转换成 JSON 这样的表述形式作为资源发送给客户端。 使用 @RequestBody 注解实现在请求体中接收资源状态使用 @RequestBody 注解可以告知 Spring 查找一个消息转换器，将来自客户端的资源表述转换为对象。如： 1234@PostMapping(value = "/employ", produces = &#123; "application/json;charset=UTF-8" &#125;)public int saveEmploy(@RequestBody EmployeeEntity employeeEntity) &#123; return empService.save(employeeEntity);&#125; 使用 @RestController 注解为控制器默认设置消息转换Spring 4.0 引入了 @RestController 注解，在控制器是用 @RestController 代替 @Controller 的话，Spring 将会为该控制器的所有处理方法应用消息转换功能。我们不必在每个方法都添加 @ResponseBody 注解了。如： 12345678910111213141516171819202122232425262728293031323334package com.pengdh.controller;import com.pengdh.entity.EmployeeEntity;import com.pengdh.service.EmployeeService;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;/** * @author pengdh * @date: 2017-06-27 0:08 */@RestController@RequestMapping("/employs")public class EmployeeController &#123; @Autowired private EmployeeService empService; @GetMapping(value = "/list", produces = &#123; "application/json;charset=UTF-8" &#125;) public List&lt;EmployeeEntity&gt; employs(Integer offset,Integer limit) &#123; offset = offset == null ? 0 : offset; limit = limit == null ? 20 : limit; return empService.queryEmployList(offset,limit); &#125; @PostMapping(value = "/employ", produces = &#123; "application/json;charset=UTF-8" &#125;) public int saveEmploy(@RequestBody EmployeeEntity employeeEntity) &#123; return empService.save(employeeEntity); &#125;&#125; 为客户端提供其他元数据使用 ResponseEntity 提供更多响应相关的元数据可以利用 ResponseEntity 给客户端返回状态码、设置响应头信息等，如给客户端提供返回码: 1234567891011@GetMapping(value = "/&#123;id&#125;", produces = &#123; "application/json;charset=UTF-8" &#125;)public ResponseEntity&lt;EmployeeEntity&gt; employById(@PathVariable long id) &#123; HttpStatus status = null; EmployeeEntity employeeEntity = empService.selectById(id); if (employeeEntity != null) &#123; status = HttpStatus.OK; &#125; else &#123; status = HttpStatus.NOT_FOUND; &#125; return new ResponseEntity&lt;EmployeeEntity&gt;(employeeEntity, status);&#125; 如果没有 if 判断，当根据 id 找不到对应的信息的时候，返回给客户端的状态码是默认的 HttpStatus.OK；当加上了判断条件后如果没有相应的信息返回则设置返回状态码为 HttpStatus.NOT_FOUND，最后通过 new 一个 ResponseEntity 会将查询信息和状态码一起返回到客户端。 另外，ResponseEntity 还包含有 @ResponseBody 的语义，上面示例中并没有使用 @ResponseBody 注解，但是 ResponseEntity 的负载部分同样可以渲染到响应体中。 使用控制器异常处理器 @ExceptionHandler 处理异常信息@ExceptionHandler 可以用到控制器的方法中，处理特定的异常： 创建响应包装类 ResponseResult 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.pengdh.dto;import java.io.Serializable;/** * 响应结果封装类 * * @author pengdh * @date: 2017-06-29 0:34 */public class ResponseResult&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = -3371934618173052904L; private String code; private String desc; private T data; public ResponseResult() &#123; &#125; public ResponseResult(String code, String desc) &#123; this.code = code; this.desc = desc; &#125; public ResponseResult(String code, T data) &#123; this.code = code; this.data = data; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getDesc() &#123; return desc; &#125; public void setDesc(String desc) &#123; this.desc = desc; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; @Override public String toString() &#123; return "ResponseResult&#123;" + "code='" + code + '\'' + ", desc='" + desc + '\'' + ", data=" + data + '&#125;'; &#125;&#125; 创建一个异常类 ResourceNotFoundException 123456789101112131415161718192021222324package com.pengdh.exception;/** * 资源未找到异常 * * @author pengdh * @date: 2017-06-29 0:55 */public class ResourceNotFoundException extends RuntimeException &#123; private static final long serialVersionUID = 4880328265878141724L; public ResourceNotFoundException() &#123; super(); &#125; public ResourceNotFoundException(String message) &#123; super(message); &#125; public ResourceNotFoundException(String message, Throwable cause) &#123; super(message, cause); &#125;&#125; 控制器 EmployeeController 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.pengdh.controller;import com.pengdh.dto.ResponseResult;import com.pengdh.entity.EmployeeEntity;import com.pengdh.exception.ResourceNotFound;import com.pengdh.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;/** * @author pengdh * @date: 2017-06-27 0:08 */@RestController@RequestMapping("/employs")public class EmployeeController &#123; @Autowired private EmployeeService empService; @GetMapping(value = "/&#123;id&#125;", produces = &#123; "application/json;charset=UTF-8" &#125;) public ResponseResult&lt;EmployeeEntity&gt; employById(@PathVariable long id) &#123; ResponseResult&lt;EmployeeEntity&gt; result = new ResponseResult&lt;EmployeeEntity&gt;(); HttpStatus status = null; EmployeeEntity employeeEntity = empService.selectById(id); if (employeeEntity == null) &#123; throw new ResourceNotFoundException(String.valueOf(id)); &#125; result.setCode(String.valueOf(HttpStatus.OK)); result.setData(employeeEntity); return result; &#125; @ExceptionHandler(ResourceNotFoundException.class) public ResponseResult&lt;Object&gt; handlerException(ResourceNotFoundException e) &#123; ResponseResult&lt;Object&gt; result = new ResponseResult&lt;Object&gt;(); result.setCode(String.valueOf(HttpStatus.NOT_FOUND)); result.setDesc(e.getMessage()); return result; &#125;&#125; 从控制器代码可以看出，我们通过 @ExceptionHandler 能将控制器的方法的异常场景分出来单独处理。 使用 @RestControllerAdvice 捕获所有 controller 抛出的异常@ ControllerAdvice是一个@ Component，用于定义@ ExceptionHandler的，@InitBinder和@ModelAttribute方法，适用于所有使用@ RequestMapping方法。 新建一个异常处理类 GlobalExceptionHandler 1234567891011121314151617181920212223package com.pengdh.exception;import com.pengdh.dto.ResponseResult;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.bind.annotation.RestControllerAdvice;/** * 全局异常处理器 * * @author pengdh * @date: 2017-07-11 0:00 */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(ResourceNotFoundException.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ResponseResult&lt;Object&gt; handlerException(ResourceNotFoundException e) &#123; return new ResponseResult&lt;Object&gt;(String.valueOf(HttpStatus.NOT_FOUND), e.getMessage()); &#125;&#125; 控制器 EmployeeController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.pengdh.controller;import com.pengdh.dto.ResponseResult;import com.pengdh.entity.EmployeeEntity;import com.pengdh.exception.ResourceNotFoundException;import com.pengdh.service.EmployeeService;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author pengdh * @date: 2017-06-27 0:08 */@RestController@RequestMapping("/employs")public class EmployeeController &#123; @Autowired private EmployeeService empService; @GetMapping(value = "/list", produces = &#123; "application/json;charset=UTF-8" &#125;) public List&lt;EmployeeEntity&gt; employs(Integer offset,Integer limit) &#123; offset = offset == null ? 0 : offset; limit = limit == null ? 20 : limit; return empService.queryEmployList(offset,limit); &#125; @PostMapping(value = "/employ", produces = &#123; "application/json;charset=UTF-8" &#125;) public int saveEmploy(@RequestBody EmployeeEntity employeeEntity) &#123; return empService.save(employeeEntity); &#125; @GetMapping(value = "/&#123;id&#125;", produces = &#123; "application/json;charset=UTF-8" &#125;) public ResponseResult&lt;EmployeeEntity&gt; employById(@PathVariable long id) &#123; ResponseResult&lt;EmployeeEntity&gt; result = new ResponseResult&lt;EmployeeEntity&gt;(); HttpStatus status = null; EmployeeEntity employeeEntity = empService.selectById(id); if (employeeEntity == null) &#123; throw new ResourceNotFoundException(String.valueOf(id)); &#125; result.setCode(String.valueOf(HttpStatus.OK)); result.setData(employeeEntity); return result; &#125;&#125; 从代码可以看出，我们将 controller 中的异常方法移到了一个新增的异常处理类。这样，如果其他 controller 类也抛出 ResourceNotFoundException 异常的时候，就会被 GlobalExceptionHandler 捕获。 参考文献 Spring in action 理解RESTful架构 RESTful API 设计指南 Restful API 的设计规范 HTTP API 设计指南 好RESTful API的设计原则 RESTful API 设计最佳实践]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十四）：适配器模式]]></title>
      <url>%2F2017%2F06%2F24%2Fadapter-pattern%2F</url>
      <content type="text"><![CDATA[适配器模式（adapter pattern）适配器模式（adapter pattern）：属于对象的结构型模式。将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式有两种类型：类适配器模式和对象适配器模式。由于类适配器模式需要多继承，而 java 不支持多继承，所以这里讨论的是对象适配器模式。 适配器模式UML图 适配器模式涉及的角色目标（Target）角色：这是客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。适配者（Adaptee）角色：需要适配的类。适配器（Adapter）角色：通过在内部包装一个适配者对象，把源接口转换成目标接口。 示例代码目标类 Target 1234567891011package com.example.adapterPattern;/** * 适配器模式：目标抽象类 * * @author pengdh * @date: 2017-06-24 22:47 */public interface Target &#123; void request();&#125; 适配者类 Adaptee 12345678910111213package com.example.adapterPattern;/** * 适配器模式：适配者类 * * @author pengdh * @date: 2017-06-24 22:49 */public class Adaptee &#123; public void specificRequest() &#123; System.out.println("特殊的请求"); &#125;&#125; 适配器类 Adapter 1234567891011121314151617package com.example.adapterPattern;/** * 适配器模式：适配器类 * * @author pengdh * @date: 2017-06-24 22:49 */public class Adapter implements Target &#123; private Adaptee adaptee; @Override public void request() &#123; adaptee = new Adaptee(); adaptee.specificRequest(); &#125;&#125; 客户端测试类 AdapterTest 123456789101112131415package com.example.adapterPattern;/** * 适配器模式：客户端测试类 * * @author pengdh * @date: 2017-06-24 22:50 */public class AdapterTest &#123; public static void main(String[] args) &#123; Target target = new Adapter(); target.request(); &#125;&#125; 适配器适用场景在系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围职位的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。 适配器模式的优点更好的复用性：系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。更好的扩展性：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。 适配器模式的缺点过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十三）：状态模式]]></title>
      <url>%2F2017%2F06%2F17%2Fstate-pattern%2F</url>
      <content type="text"><![CDATA[状态模式（state pattern）状态模式（state pattern）：属于对象的行为型模式。又叫状态对象模式（pattern of objects for state）；当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变其了类。 状态模式UML图 状态模式涉及的角色抽象状态（State）角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态相关的行为。环境(Context)角色：维护一个具体状态（ConcreteState）实例，这个实例定义当前的状态。具体状态（ConcreteState）角色：每一个具体状态（ConcreteState）实例都实现了与环境（Context）对象的一个状态相关的行为。 示例代码抽象状态类 State 123456789package com.example.statePattern;/** * 状态模式：状态接口类 * Created by Administrator on 2017/3/21. */public interface State &#123; public void handle(Context context);&#125; 环境类 Context 1234567891011121314151617181920212223package com.example.statePattern;/** * 状态模式：环境类 * * @author pengdh * @date: 2017-03-21 22:01 */public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; public void setState(State state) &#123; this.state = state; &#125; // 对请求做处理并设置下一状态 public void request() &#123; state.handle(this); &#125;&#125; 具体状态类A ConcreteStateA 12345678910111213141516package com.example.statePattern;/** * 状态模式：具体状态类 * * @author pengdh * @date: 2017-03-21 22:05 */public class ConcreteStateA implements State &#123; @Override public void handle(Context context) &#123; // 设置 ConcreteStateA 的下一状态是 ConcreteStateB context.setState( new ConcreteStateB()); //context.request(); &#125;&#125; 具体状态类B ConcreteStateB 12345678910111213141516package com.example.statePattern;/** * 状态模式：具体状态类 * * @author pengdh * @date: 2017-03-21 22:10 */public class ConcreteStateB implements State &#123; @Override public void handle(Context context) &#123; // 设置 ConcreteStateB 的下一状态是 ConcreteStateA context.setState( new ConcreteStateA()); //context.request(); &#125;&#125; 客户端测试类 123456789101112131415package com.example.statePattern;/** * 状态模式测试类 * * @author pengdh * @date: 2017-03-21 22:13 */public class TestStatePattern &#123; public static void main(String[] args) &#123; Context c = new Context(new ConcreteStateA()); c.request(); c.request(); &#125;&#125; 状态模式的优点 状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。也就是说可以将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个 ConcreteState 中，所以通过定义新的子类可以很容易地增加行的状态和转换。这样可以消除庞大的条件分支语句。 状态模式通过把各种状态转移逻辑分布到 State 的子类之间，来减少相互间的依赖。 状态模式使用场景当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十二）：抽象工厂模式]]></title>
      <url>%2F2017%2F06%2F11%2Fabstract-factory-pattern%2F</url>
      <content type="text"><![CDATA[抽象工厂模式（abstract factory pattern）抽象工厂模式（abstract factory pattern）：属于对象的创建型模式。提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。 抽象工厂模式UML图 抽象工厂模式涉及的角色抽象工厂（AbstractFactory）角色：是一个抽象接口，它里面包含所有产品创建的抽象方法。具体工厂（ConcreteFactory）角色：具体工厂角色通常是在运行时刻再创建，这个具体的工厂再去创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。抽象产品（AbstractProduct）角色：用来创建不同的实现。具体产品（ConcreteProduct）角色：抽象产品的实现。 示例代码实体类 User 12345678910111213141516171819202122232425262728package com.example.abstractFactoryPattern;/** * 抽象工厂模式：实体类 User * * @author pengdh * @date: 2017-06-11 1:33 */public class User &#123; private String userId; private String userName; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125;&#125; 实体类 Department 12345678910111213141516171819202122232425262728package com.example.abstractFactoryPattern;/** * 抽象工厂模式：实体类 Department * * @author pengdh * @date: 2017-06-11 1:35 */public class Department &#123; private String departId; private String departName; public String getDepartId() &#123; return departId; &#125; public void setDepartId(String departId) &#123; this.departId = departId; &#125; public String getDepartName() &#123; return departName; &#125; public void setDepartName(String departName) &#123; this.departName = departName; &#125;&#125; 抽象产品类 AbstractUser 123456789101112package com.example.abstractFactoryPattern;/** * 抽象工厂模式：抽象类 AbstractUser,类似 AbstractProductA 类 * * @author pengdh * @date: 2017-06-11 1:45 */public abstract class AbstractUser &#123; public abstract void insert(User user); public abstract User query(String id);&#125; 抽象产品类 AbstractDepartment 123456789101112package com.example.abstractFactoryPattern;/** * 抽象工厂模式：抽象类 AbstractDepartment，类似 AbstractProductB 类 * * @author pengdh * @date: 2017-06-11 1:58 */public abstract class AbstractDepartment &#123; public abstract void inser(Department department); public abstract Department query(String id);&#125; 产品类 MysqlUser 1234567891011121314151617181920package com.example.abstractFactoryPattern;/** * 抽象工厂模式：MysqlUser类，类似 ProductA1 类 * * @author pengdh * @date: 2017-06-11 1:50 */public class MysqlUser extends AbstractUser &#123; @Override public void insert(User user) &#123; System.out.println("在 mysql 中插入一条 User 记录"); &#125; @Override public User query(String id) &#123; System.out.println("在 mysql 中查询一条 User 记录"); return null; &#125;&#125; 产品类 OracleUser 1234567891011121314151617181920package com.example.abstractFactoryPattern;/** * 抽象工厂模式：OracleUser 类，类似 ProductA2 类 * * @author pengdh * @date: 2017-06-11 1:56 */public class OracleUser extends AbstractUser &#123; @Override public void insert(User user) &#123; System.out.println("在 oracle 中插入一条 User 记录"); &#125; @Override public User query(String id) &#123; System.out.println("在 oracle 中查询一条 User 记录"); return null; &#125;&#125; 产品类 MysqlDepartment 1234567891011121314151617181920package com.example.abstractFactoryPattern;/** * 抽象工厂模式：MysqlDepartment 类，类似 ProductB1 类 * * @author pengdh * @date: 2017-06-11 2:01 */public class MysqlDepartment extends AbstractDepartment &#123; @Override public void inser(Department department) &#123; System.out.println("在 mysql 中插入一条 Department 记录"); &#125; @Override public Department query(String id) &#123; System.out.println("在 mysql 中查询一条 Department 记录"); return null; &#125;&#125; 产品类 OracleDepartment 1234567891011121314151617181920package com.example.abstractFactoryPattern;/** * 抽象工厂模式：OracleDepartment 类，类似 ProductB2 类 * * @author pengdh * @date: 2017-06-11 2:03 */public class OracleDepartment extends AbstractDepartment &#123; @Override public void inser(Department department) &#123; System.out.println("在 oracle 中插入一条 Department 记录"); &#125; @Override public Department query(String id) &#123; System.out.println("在 oracle 中查询一条 Department 记录"); return null; &#125;&#125; 抽象工厂类 AbstractFactory 123456789101112package com.example.abstractFactoryPattern;/** * 抽象工厂模式：AbstractFactory 类，定义访问两个实体对象的的抽象工厂类 * * @author pengdh * @date: 2017-06-11 2:04 */public abstract class AbstractFactory &#123; public abstract AbstractUser createUser(); public abstract AbstractDepartment createDepartment();&#125; 具体工厂类 MysqlFacory 12345678910111213141516171819package com.example.abstractFactoryPattern;/** * 抽象工厂模式：MysqlFacory 类，类似 ConcreteFactory1 类，用于实例化 MysqlUser 和 MysqlDepartment * * @author pengdh * @date: 2017-06-11 2:08 */public class MysqlFacory extends AbstractFactory &#123; @Override public AbstractUser createUser() &#123; return new MysqlUser(); &#125; @Override public AbstractDepartment createDepartment() &#123; return new MysqlDepartment(); &#125;&#125; 具体工厂类 OracleFacory 12345678910111213141516171819package com.example.abstractFactoryPattern;/** * 抽象工厂模式：OracleFacory 类，类似 ConcreteFactory2 类，用于实例化 OracleUser 和 OracleDepartment * * @author pengdh * @date: 2017-06-11 2:12 */public class OracleFactory extends AbstractFactory &#123; @Override public AbstractUser createUser() &#123; return new OracleUser(); &#125; @Override public AbstractDepartment createDepartment() &#123; return new OracleDepartment(); &#125;&#125; 客户端测试类 TestAbstractFactoryPattern 12345678910111213141516171819202122232425262728293031package com.example.abstractFactoryPattern;/** * 抽象工厂模式：客户端测试类 TestAbstractFactoryPattern * * @author pengdh * @date: 2017-06-11 2:15 */public class TestAbstractFactoryPattern &#123; public static void main(String[] args) &#123; User user = new User(); Department department = new Department(); AbstractFactory mysqlFacory = new MysqlFacory(); AbstractFactory oracleFactory = new OracleFactory(); AbstractUser muser = mysqlFacory.createUser(); muser.insert(user); muser.query("1"); AbstractDepartment mdepartment = mysqlFacory.createDepartment(); mdepartment.inser(department); mdepartment.query("1"); AbstractUser ouser = oracleFactory.createUser(); ouser.insert(user); ouser.query("2"); AbstractDepartment odepartment = oracleFactory.createDepartment(); odepartment.inser(department); odepartment.query("2"); &#125;&#125; 抽象工厂模式优缺点两个概念 产品等级结构：产品等级是由相同的结构的产品组成。如组成电脑的 主板、芯片组、CPU。 产品族：是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。 抽象工厂模式的优点 分离接口和实现：客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。 使切换产品族变得容易：因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。 抽象工厂模式的缺点 不太容易扩展新的产品：如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。例如，如果再增加一个项目表 Project,则需要增加三个类，AbstractProject、MysqlProject、OracleProject，还需要更改 AbstractFactory、MysqlFactory、OracleFactory 才可以实现。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十一）：观察者模式]]></title>
      <url>%2F2017%2F05%2F30%2Fobserver-pattern%2F</url>
      <content type="text"><![CDATA[观察者模式（observer pattern）观察者模式（observer pattern）：属于对象的行为型模式。定义了一种一对多的依赖关系，让多个观察者对象同事监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。观察者模式又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 观察者模式UML图 观察者模式涉及的角色抽象主题（Subject）角色：Subject 类，它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。具体主题(ConcreteSubject)角色：将有关状态存入具体现观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。具体观察者(ConcreteObserver)角色：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。 示例代码抽象主题类 Subject 123456789101112131415161718192021222324252627282930313233343536373839package com.example.observerPattern;import java.util.ArrayList;import java.util.List;/** * 观察者模式：抽象主题类 * * @author pengdh * @date: 2017-05-30 12:06 */public abstract class Subject &#123; private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 增加观察者 * @param observer */ public void attach(Observer observer) &#123; list.add(observer); &#125; /** * 移除观察者 * @param observer */ public void detach(Observer observer) &#123; list.remove(observer); &#125; /** * 发布通知 */ public void notifyObservers() &#123; for (Observer observer : list) &#123; observer.update(); &#125; &#125;&#125; 具体主题类 ConcreteSubject 12345678910111213141516171819package com.example.observerPattern;/** * 观察者模式：具体主题类 * * @author pengdh * @date: 2017-05-30 12:26 */public class ConcreteSubject extends Subject &#123; private String subjectState; public String getSubjectState() &#123; return subjectState; &#125; public void setSubjectState(String subjectState) &#123; this.subjectState = subjectState; &#125;&#125; 抽象观察者类 Observer 1234567891011package com.example.observerPattern;/** * 观察者模式：抽象观察者 * * @author pengdh * @date: 2017-05-30 12:07 */public abstract class Observer &#123; public abstract void update();&#125; 具体观察者类 ConcreteObserver 1234567891011121314151617181920212223242526272829303132package com.example.observerPattern;/** * 观察者模式：具体观察者类 * * @author pengdh * @date: 2017-05-30 12:19 */public class ConcreteObserver extends Observer &#123; private String name; private String observerState; private ConcreteSubject subject; public ConcreteObserver(String name, ConcreteSubject subject) &#123; this.name = name; this.subject = subject; &#125; @Override public void update() &#123; observerState = subject.getSubjectState(); System.out.println("观察者：" + name + " 的新状态是：" + observerState); &#125; public ConcreteSubject getSubject() &#123; return subject; &#125; public void setSubject(ConcreteSubject subject) &#123; this.subject = subject; &#125;&#125; 客户端测试类 TestObserverPattern 123456789101112131415161718package com.example.observerPattern;/** * 观察者模式：客户端测试类 * * @author pengdh * @date: 2017-05-30 12:43 */public class TestObserverPattern &#123; public static void main(String[] args) &#123; ConcreteSubject s = new ConcreteSubject(); s.attach(new ConcreteObserver("obs1", s)); s.attach(new ConcreteObserver("obs2", s)); s.setSubjectState("new state"); s.notifyObservers(); &#125;&#125; 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（十）：建造者模式]]></title>
      <url>%2F2017%2F05%2F29%2Fbuilder-pattern%2F</url>
      <content type="text"><![CDATA[建造者模式（builder pattern）建造者模式（builder pattern）：属于对象的创建型模式。将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式UML 建造者模式涉及的角色抽象建造者（Builder）角色：是为创建一个 Product 对象的各个部件指定的抽象接口。此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是建造方法(buildPart1和 buildPart2)，另一种是返还结构方法(getResult)。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少 零件，就有多少相应的建造方法。具体建造者（ConcreteBuilder）角色：它是具体的建造者，实现 Builder 接口，构造和装配各个部件。担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。这个角色要完成的任务包括：1.实现抽象建造者Builder所声明的接口，给出一步一步地完成创建产品实例的操作。2.在建造过程完成后，提供产品的实例。指挥者（Director）角色：它调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。产品（Product）角色：产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。 示例代码产品类 Product 12345678910111213141516171819202122232425262728package com.example.builderPattern;/** * 建造者模式：产品类 * * @author pengdh * @date: 2017-05-29 22:47 */public class Product &#123; private String part1; private String part2; public String getPart1() &#123; return part1; &#125; public void setPart1(String part1) &#123; this.part1 = part1; &#125; public String getPart2() &#123; return part2; &#125; public void setPart2(String part2) &#123; this.part2 = part2; &#125;&#125; 抽象建造者类 Builder 12345678910111213141516171819202122232425package com.example.builderPattern;/** * 建造者模式：抽象建造者类 * * @author pengdh * @date: 2017-05-29 22:50 */public interface Builder &#123; /** * 建造产品部件1 */ public void buildPart1(); /** * 建造产品部件2 */ public void buildPart2(); /** * 返回产品 * @return */ public Product getResult();&#125; 具体建造者类 ConcreteBuilder 12345678910111213141516171819202122232425package com.example.builderPattern;/** * 建造者模式：具体建造者类 * * @author pengdh * @date: 2017-05-29 22:52 */public class ConcreteBuilder implements Builder &#123; private Product product = new Product(); @Override public void buildPart1() &#123; product.setPart1("建造产品部件1"); &#125; @Override public void buildPart2() &#123; product.setPart2("建造产品部件2"); &#125; @Override public Product getResult() &#123; return product; &#125;&#125; 指挥者类 Director 1234567891011121314151617181920212223package com.example.builderPattern;/** * 建造者模式：指挥者类 * * @author pengdh * @date: 2017-05-29 22:58 */public class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; /** * 构造产品方法 */ public void construct() &#123; builder.buildPart1(); builder.buildPart2(); &#125;&#125; 客户端测试类 TestBuilderPattern 123456789101112131415161718package com.example.builderPattern;/** * 建造者模式：客户端测试类 * * @author pengdh * @date: 2017-05-29 23:02 */public class TestBuilderPattern &#123; public static void main(String[] args) &#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); director.construct(); Product product = builder.getResult(); System.out.println(product.getPart1()); System.out.println(product.getPart2()); &#125;&#125; 建造者模式使用场景建造者模式主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。 建造者模式的优点建造者模式的好处就是使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（九）：外观模式]]></title>
      <url>%2F2017%2F05%2F28%2Ffacade-pattern%2F</url>
      <content type="text"><![CDATA[外观模式（facade pattern）外观模式（facade pattern）：属于对象结构模式。又称为门面模式,为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式UML图 外观模式涉及的角色外观（Facade）角色：客户端直接调用这个角色的方法，该角色知道哪些子系统类负责处理请求，将客户的请求代理给适当的子系统对象。子系统（SubSystem）角色：子系统角色集合实现子系统的功能，处理 Facade 对象指派的任务。注意子类中没有 Facade 的任何信息，即没有对 Facade 对象的引用。 示例代码外观类 Facade 12345678910111213141516171819202122232425package com.example.facadePattern;/** * 外观模式：门面类 * * @author pengdh * @date: 2017-05-28 22:32 */public class Facade &#123; private SubModuleA subModuleA; private SubModuleB subModuleB; private SubModuleC subModuleC; public Facade() &#123; this.subModuleA = new SubModuleA(); this.subModuleB = new SubModuleB(); this.subModuleC = new SubModuleC(); &#125; public void testFacade() &#123; subModuleA.methodA(); subModuleB.methodB(); subModuleC.methodC(); &#125;&#125; 子系统（SubSystem）集合中的类A SubModuleA 12345678910111213package com.example.facadePattern;/** * 外观模式：子系统A * * @author pengdh * @date: 2017-05-28 22:33 */public class SubModuleA &#123; public void methodA() &#123; System.out.println("子系统 SubModuleA 的方法 methodA 被调用！"); &#125;&#125; 子系统（SubSystem）集合中的类B SubModuleB 12345678910111213package com.example.facadePattern;/** * 外观模式：子系统B * * @author pengdh * @date: 2017-05-28 22:34 */public class SubModuleB &#123; public void methodB() &#123; System.out.println("子系统 SubModuleB 的方法 methodB 被调用！"); &#125;&#125; 子系统（SubSystem）集合中的类C SubModuleC 12345678910111213package com.example.facadePattern;/** * 外观模式：子系统C * * @author pengdh * @date: 2017-05-28 22:34 */public class SubModuleC &#123; public void methodC() &#123; System.out.println("子系统 SubModuleC 的方法 methodC 被调用！"); &#125;&#125; 客户端（Client）测试类 TestFacadePattern 1234567891011121314package com.example.facadePattern;/** * 外观模式：客户端测试类 * * @author pengdh * @date: 2017-05-28 22:43 */public class TestFacadePattern &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.testFacade(); &#125;&#125; 外观模式优点 松散耦合：外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。 简单易用：外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。 更好的划分访问层次：通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（八）：模板方法模式]]></title>
      <url>%2F2017%2F05%2F21%2Ftemplate-method-pattern%2F</url>
      <content type="text"><![CDATA[模板方法模式（template method pattern）模板方法模式（template method pattern）：属于行为型模式。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式UML图 模板方法模式涉及的角色抽象模板（Abstract Template）角色： 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成不走在相应的抽象操作中，推迟到子类实现。顶级逻辑也可能顶用一些具体方法。 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作基本操作，它们是一个顶级逻辑的组成步骤。具体模板（Concrete Template）角色： 实现父类所定义的一个或多个抽象方法。它们是一个顶级逻辑的组成步骤。 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 示例代码抽象模板类 AbstractTemplate 12345678910111213141516171819202122232425262728293031323334package com.example.templateMethodPattern;/** * 模板方法模式：抽象模板类 * * @author pengdh * @date: 2017-05-21 20:53 */public abstract class AbstractTemplate &#123; /** * 模板方法 */ public void templateMethod() &#123; primitiveOperation1(); primitiveOperation2(); concreteMethod(); &#125; /** * 申明抽象基本方法，由子类具体实现 */ protected abstract void primitiveOperation1(); /** * 申明抽象基本方法，由子类具体实现 */ protected abstract void primitiveOperation2(); /** * 基本方法 */ private void concreteMethod() &#123; &#125;&#125; 具体模板类A ConcreteTemplateA 12345678910111213141516171819package com.example.templateMethodPattern;/** * 模板方法模式：具体模板类A * * @author pengdh * @date: 2017-05-21 21:01 */public class ConcreteTemplateA extends AbstractTemplate &#123; @Override protected void primitiveOperation1() &#123; System.out.println("具体模板类A实现方法1"); &#125; @Override protected void primitiveOperation2() &#123; System.out.println("具体模板类A实现方法2"); &#125;&#125; 具体模板类B ConcreteTemplateB 12345678910111213141516171819package com.example.templateMethodPattern;/** * 模板方法模式：具体模板类B * * @author pengdh * @date: 2017-05-21 21:08 */public class ConcreteTemplateB extends AbstractTemplate &#123; @Override protected void primitiveOperation1() &#123; System.out.println("具体模板类B实现方法1"); &#125; @Override protected void primitiveOperation2() &#123; System.out.println("具体模板类B实现方法2"); &#125;&#125; 客户端测试类 TestTemplateMethod 1234567891011121314151617package com.example.templateMethodPattern;/** * 模板方法模式：客户端测试类 * * @author pengdh * @date: 2017-05-21 21:11 */public class TestTemplateMethod &#123; public static void main(String[] args) &#123; AbstractTemplate abstractTemplate = new ConcreteTemplateA(); abstractTemplate.templateMethod(); abstractTemplate = new ConcreteTemplateB(); abstractTemplate.templateMethod(); &#125;&#125; 模板方法模式特点模板方法模式是通过把不变行为搬移到超类，去除了子类中的重复代码来实现它的优势。 模板方法模式使用场景当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类办妥重复的不变行为的纠缠。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（七）：原型模式]]></title>
      <url>%2F2017%2F05%2F14%2Fprototype-pattern%2F</url>
      <content type="text"><![CDATA[原型模式（prototype pattern）原型模式（prototype pattern）：属于对象的创建型设计模式。用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式UML图 原型模式涉及的角色客户角色（Client）：提出创建对象的请求。抽象原型角色（Prototype）：申明一个克隆自身的接口或抽象类，此角色给出所有具体原型类所需要的接口。具体原型角色（Concrete Prototype）：被复制的对象，该角色需要实现抽象的原型角色的所有接口。 示例代码抽象原型类 Prototype： 1234567891011package com.example.prototypePattern;/** * 原型模式：抽象原型类 * * @author pengdh * @date: 2017-05-14 21:35 */public interface Prototype &#123; public Object clone();&#125; 具体原型类 ConcretePrototype1： 12345678910111213141516package com.example.prototypePattern;/** * 原型模式：具体原型类 * * @author pengdh * @date: 2017-05-14 21:38 */public class ConcretePrototype1 implements Prototype &#123; @Override public Object clone() &#123; // 最基本的克隆方式，新建一个自身对象 Prototype prototype = new ConcretePrototype1(); return prototype; &#125;&#125; 具体原型类 ConcretePrototype2： 12345678910111213141516package com.example.prototypePattern;/** * 原型模式：具体原型类 * * @author pengdh * @date: 2017-05-14 21:42 */public class ConcretePrototype2 implements Prototype &#123; @Override public Object clone() &#123; // 最基本的克隆方式，新建一个自身对象 Prototype prototype = new ConcretePrototype2(); return prototype; &#125;&#125; 客户角色 Client： 123456789101112131415161718192021222324package com.example.prototypePattern;/** * 原型模式：客户端类 * * @author pengdh * @date: 2017-05-14 21:43 */public class Client &#123; // 申明一个原型接口的对象 private Prototype prototype; /** * 构造方法，传入需要使用的原型接口对象 * @param prototype */ public Client(Prototype prototype) &#123; this.prototype = prototype; &#125; public void operation(Prototype p) &#123; // 需要创建原型接口的对象 Prototype copyPrototype = (Prototype) prototype.clone(); &#125;&#125; 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（六）：工厂方法模式]]></title>
      <url>%2F2017%2F05%2F09%2Ffactory-method-pattern%2F</url>
      <content type="text"><![CDATA[工厂方法模式（factory method pattern）工厂方法模式（factory method pattern）：属于对象的创建型模式。定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。 工厂方法模式UML图 工厂方法模式涉及的角色抽象角色：工厂方法模式所创建的对象的超类。如图中 Operation。具体角色：具体角色，实现具体角色。如图中 OperationAdd、OperationSub、OperationMul、OperationDiv。抽象工厂角色 ：这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。如图中 Ifactory。具体工厂角色 ：抽象工厂接口的具体实现，含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类。如图中 AddFactory、SubFactory、MulFactory、DivFactory。 示例代码运算类 OperationFactory 12345678910package com.example.FactoryMethodPattern;/** * 工厂方法模式：运算接口 * * @author pengdh * @date: 2017-05-08 1:20 */public interface OperationFactory &#123; double getResult();&#125; 运算抽象类 AbstractOperation 12345678910111213141516171819202122232425262728293031323334package com.example.FactoryMethodPattern;/** * 工厂方法模式：运算工厂抽象类 主要目的是将各个计算类要用的变量写在这里，避免每个计算实现类都写一个 * * @author pengdh * @date: 2017-05-08 1:20 */public class AbstractOperation implements OperationFactory &#123; protected double numberA; protected double numberB; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; @Override public double getResult() &#123; double result = 0L; return result; &#125;&#125; 加法运算类 OperationAdd 123456789101112131415package com.example.FactoryMethodPattern;/** * 工厂方法模式：加法计算类 * * @author pengdh * @date: 2017-05-08 1:31 */public class OperationAdd extends AbstractOperation implements OperationFactory &#123; @Override public double getResult() &#123; double result = 0L; return numberA + numberB; &#125;&#125; 减法运算类 OperationSub 1234567891011121314package com.example.FactoryMethodPattern;/** * 工厂方法模式：减法计算类 * * @author pengdh * @date: 2017-05-08 1:37 */public class OperationSub extends AbstractOperation &#123; public double getResult() &#123; double result = 0L; return numberA - numberB; &#125;&#125; 乘法运算类 OperationMul 1234567891011121314package com.example.FactoryMethodPattern;/** * 工厂方法模式：乘法计算类 * * @author pengdh * @date: 2017-05-08 1:39 */public class OperationMul extends AbstractOperation &#123; public double getResult() &#123; double result = 0L; return numberA * numberB; &#125;&#125; 除法运算类 OperationDiv 1234567891011121314package com.example.FactoryMethodPattern;/** * 工厂方法模式：除法计算类 * * @author pengdh * @date: 2017-05-08 1:40 */public class OperationDiv extends AbstractOperation &#123; public double getResult() &#123; double result = 0L; return numberA / numberB; &#125;&#125; 工厂接口类 IFactory 1234567891011package com.example.FactoryMethodPattern;/** * 工厂方法模式：工厂接口 * * @author pengdh * @date: 2017-05-08 1:20 */public interface IFactory &#123; AbstractOperation createOperation();&#125; 加法工厂类 AddFactory 1234567891011121314package com.example.FactoryMethodPattern;/** * 工厂方法模式：加法工厂 * * @author pengdh * @date: 2017-05-08 1:46 */public class AddFactory implements IFactory &#123; @Override public AbstractOperation createOperation() &#123; return new OperationAdd(); &#125;&#125; 减法工厂类 SubFactory 1234567891011121314package com.example.FactoryMethodPattern;/** * 工厂方法模式：减法工厂 * * @author pengdh * @date: 2017-05-08 2:02 */public class SubFactory implements IFactory &#123; @Override public AbstractOperation createOperation() &#123; return new OperationSub(); &#125;&#125; 乘法工厂类 MulFactory 1234567891011121314package com.example.FactoryMethodPattern;/** * 工厂方法模式：乘法工厂 * * @author pengdh * @date: 2017-05-08 2:03 */public class MulFactory implements IFactory &#123; @Override public AbstractOperation createOperation() &#123; return new OperationMul(); &#125;&#125; 除法工厂类 DivFactory 1234567891011121314package com.example.FactoryMethodPattern;/** * 工厂方法模式：除法工厂 * * @author pengdh * @date: 2017-05-08 2:04 */public class DivFactory implements IFactory &#123; @Override public AbstractOperation createOperation() &#123; return new OperationDiv(); &#125;&#125; 客户端测试类 FactoryMethodTest 12345678910111213141516171819package com.example.FactoryMethodPattern;/** * 工厂方法模式：测试类 * * @author pengdh * @date: 2017-05-08 1:41 */public class FactoryMethodTest &#123; public static void main(String[] args) &#123; IFactory factory = new AddFactory(); AbstractOperation add = new OperationAdd(); // 需要修改其他计算方法，修改这里就可以 add = factory.createOperation(); add.numberA = 1; add.numberB = 2; double result = add.getResult(); System.out.println(result); &#125;&#125; 工厂方法模式与简单工厂模式比较工厂方法模式克服了简单工厂模式违背的开放-封闭原则的缺点，它是简单工厂模式的进一步抽象和广，从而降低了客户端与产品的耦合，增加对应计算类的抽象工厂这样就把简单工厂的内部逻辑判断转移到了客户端代码类来进行。本来是改工厂类，而现在是修改客户端。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[log4j-properties 日志配置]]></title>
      <url>%2F2017%2F05%2F03%2Flog4j-properties-config%2F</url>
      <content type="text"><![CDATA[常使用的配置123456789101112131415161718192021222324252627282930313233343536373839log4j.rootLogger=DEBUG, console, log, error###Console ###log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Threshold = DEBUGlog4j.appender.console.Target = System.outlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern = %d %p[%C:%L]- %m%n### log ###log4j.appender.log = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.log.File = $&#123;catalina.base&#125;/logs/player/player.loglog4j.appender.log.Append = truelog4j.appender.log.Threshold = DEBUGlog4j.appender.log.DatePattern='.'yyyy-MM-ddlog4j.appender.log.layout = org.apache.log4j.PatternLayoutlog4j.appender.log.layout.ConversionPattern = %d %p[%c:%L] - %m%n### Error ###log4j.appender.error = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.error.File = $&#123;catalina.base&#125;/logs/player/error.loglog4j.appender.error.Append = truelog4j.appender.error.Threshold = ERROR log4j.appender.error.DatePattern='.'yyyy-MM-ddlog4j.appender.error.layout = org.apache.log4j.PatternLayoutlog4j.appender.error.layout.ConversionPattern =%d %p[%c:%L] - %m%n### SQLlog4j.logger.com.ibatis=DEBUGlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUGlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUGlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUGlog4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUGlog4j.logger.java.sql.ResultSet=INFOlog4j.logger.org.apache=INFO 文件配置方法 根 Logger 配置 log4j.rootLogger = [ level ] , appenderName, appenderName, … level 是日志记录优先级别，从高到低依次为：off,fatal,error,warn,info,debug,all off 最高等级，用于关闭所有日志记录。fatal 指出每个严重的错误事件将会导致应用程序的退出。error 指出虽然发生错误事件，但仍然不影响系统的继续运行。warn 表明会出现潜在的错误情形。info 一般和在粗粒度级别上，强调应用程序的运行全程。debug 一般用于细粒度级别上，对调试应用程序非常有帮助。all 最低等级，用于打开所有日志记录。 配置日志信息输出目的地Appender log4j.appender.appenderName = fully.qualified.name.of.appender.classlog4j.appender.appenderName.option1 = value1…log4j.appender.appenderName.option = valueN 其中，Log4j提供的appender有以下几种： org.apache.log4j.ConsoleAppender（控制台），org.apache.log4j.FileAppender（文件），org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） ConsoleAppender选项属性 -Threshold = DEBUG:指定日志消息的输出最低层次 -ImmediateFlush = TRUE:默认值是true,所有的消息都会被立即输出 -Target = System.err:默认值System.out,输出到控制台(err为红色,out为黑色) FileAppender选项属性 -Threshold = INFO:指定日志消息的输出最低层次 -ImmediateFlush = TRUE:默认值是true,所有的消息都会被立即输出 -File = C:\log4j.log:指定消息输出到C:\log4j.log文件 -Append = FALSE:默认值true,将消息追加到指定文件中，false指将消息覆盖指定的文件内容 -Encoding = UTF-8:可以指定文件编码格式 DailyRollingFileAppender选项属性 -Threshold = WARN:指定日志消息的输出最低层次 -ImmediateFlush = TRUE:默认值是true,所有的消息都会被立即输出 -File = C:\log4j.log:指定消息输出到C:\log4j.log文件 -Append = FALSE:默认值true,将消息追加到指定文件中，false指将消息覆盖指定的文件内容 -DatePattern=’.’yyyy-ww:每周滚动一次文件,即每周产生一个新的文件。还可以按用以下参数: ‘.’yyyy-MM:每月 ‘.’yyyy-ww:每周 ‘.’yyyy-MM-dd:每天 ‘.’yyyy-MM-dd-a:每天两次 ‘.’yyyy-MM-dd-HH:每小时 ‘.’yyyy-MM-dd-HH-mm:每分钟 -Encoding = UTF-8:可以指定文件编码格式 RollingFileAppender选项属性 -Threshold = ERROR:指定日志消息的输出最低层次 -ImmediateFlush = TRUE:默认值是true,所有的消息都会被立即输出 -File = C:/log4j.log:指定消息输出到C:/log4j.log文件 -Append = FALSE:默认值true,将消息追加到指定文件中，false指将消息覆盖指定的文件内容 -MaxFileSize = 100KB:后缀可以是KB,MB,GB.在日志文件到达该大小时,将会自动滚动.如:log4j.log.1 -MaxBackupIndex = 2:指定可以产生的滚动文件的最大数 -Encoding = UTF-8:可以指定文件编码格式 配置日志信息的格式（布局） log4j.appender.appenderName.layout = fully.qualified.name.of.layout.classlog4j.appender.appenderName.layout.option1 = value1…log4j.appender.appenderName.layout.option = valueN 其中，Log4j提供的layout有以e几种： org.apache.log4j.HTMLLayout（以HTML表格形式布局），org.apache.log4j.PatternLayout（可以灵活地指定布局模式），org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息 -X号: X信息输出时左对齐； %p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL, %d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %r: 输出自应用启动到输出该log信息耗费的毫秒数 %c: 输出日志信息所属的类目，通常就是所在类的全名 %t: 输出产生该日志事件的线程名 %l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main (TestLog4.java:10) %x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。 %%: 输出一个”%”字符 %F: 输出日志消息产生时所在的文件名称 %L: 输出代码中的行号 %m: 输出代码中指定的消息,产生的日志具体信息 %n: 输出一个回车换行符，Windows平台为”/r/n”，Unix平台为”/n”输出日志信息换行 可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如： 1) %20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。 2) %-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，”-“号指定左对齐。 3) %.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。 4) %20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边较远输出的字符截掉。 代码中使用 SLF4J 插入日志代码中编写日志记录语句使用SLF4J的主要动机是让你的程序独立于任何特定的日志记录库，这些日志记录库可能需要与你现在配置不同的配置，而且还会引入更多令人头疼的维护问题。然而除了这个之外，SLF4J API还有一个让你使用SLF4J而不是用长期感兴趣的 Log4j 更让人信服的功能，也就是占位符功能，在代码中用{}来表示 使用SLF4J和Log4J来做日志需要引入的jar包 slf4j-api-1.7.7.jar - JAR for SLF4J API log4j-1.2.17.jar - JAR for Log4J API slf4j-log4j12-1.7.7.jar - Log4J Adapter for SLF4J 使用 maven 引入 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt;&lt;/dependency&gt; Spring中使用Log4jweb.xml增加 123456789101112131415161718&lt;!-- 设置根目录 --&gt; &lt;context-param&gt; &lt;param-name&gt;webAppRootKey&lt;/param-name&gt; &lt;param-value&gt;webapp.root&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 3000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;3000&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（五）：代理模式]]></title>
      <url>%2F2017%2F04%2F23%2Fproxy-pattern%2F</url>
      <content type="text"><![CDATA[代理模式（proxy pattern）代理模式（proxy pattern）：属于对象的结构型模式。为其他对象提供一种代理以控制这个对象的访问。 代理模式UML图 代理模式涉及的对象抽象对象（Subject）：定义了目标对象和代理对象的共用接口，这样就在任何使用目标对象的地方都可以使用代理对象。目标对象（RealSubject）：定义了代理对象所代表的真实实体。代理对象（Proxy）：代理对象内部含有目标对象的引用，这样就可以在任何时候操作目标对象，代理对象还提供了与抽象对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。 示例代码抽象类 Subject 1234567891011package com.example.proxyPattern;/** * 代理模式：定义了 RealSubject 和 Proxy 的共用接口，目的是为了在任何使用 RealSubject 的地方都能使用 Proxy * * @author pengdh * @date: 2017-04-23 13:34 */public interface Subject &#123; public void request();&#125; 目标类 RealSubject 1234567891011121314package com.example.proxyPattern;/** * 代理模式：定义 Proxy 代表的真实实体 * * @author pengdh * @date: 2017-04-23 13:38 */public class RealSubject implements Subject &#123; @Override public void request() &#123; System.out.println("真实的请求!"); &#125;&#125; 代理类 Proxy 123456789101112131415161718192021package com.example.proxyPattern;/** * 代理模式：报错一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替换实体 * * @author pengdh * @date: 2017-04-23 13:40 */public class Proxy implements Subject &#123; private RealSubject realSubject; public Proxy(RealSubject realSubject) &#123; this.realSubject = realSubject; &#125; @Override public void request() &#123; System.out.println("调用真实对象"); realSubject.request(); &#125;&#125; 客户端测试类 TestProxyPattern 123456789101112131415package com.example.proxyPattern;/** * 代理模式：客户端测试类 * * @author pengdh * @date: 2017-04-23 13:45 */public class TestProxyPattern &#123; public static void main(String[] args) &#123; RealSubject realObj = new RealSubject(); Subject obj = new Proxy(realObj); obj.request(); &#125;&#125; 代理模式应用 第一：远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。 第二：虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象（浏览器中就是用代理模式来优化下载的）。 第三：安全代理，用来控制真实对象访问时的权限。 第四：智能指引，是指当调用真实的对象时，代理处理另外一些事。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（四）：装饰模式]]></title>
      <url>%2F2017%2F04%2F21%2Fdecoretor-pattern%2F</url>
      <content type="text"><![CDATA[装饰模式（decoretor pattern）装饰模式（decoretor pattern）：属于对象的结构型模式。动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 装饰模式UML图 装饰模式涉及到的对象抽象构件对象（Component）：定义一个抽象接口，以规范准备接收附加职责的对象。具体构件对象（ConcreteComponent）：是Component的一个具体对象，也可以给这个对象添加一些附加职责。装饰对象（Decorator）：该对象存放了一个构件对象的实例，继承或实现了Component接口。具体装饰对象（ConcreteDecorator）：具体的装饰对象，负责给Component添加职责。 装饰模式的意义装饰模式是为已有功能动态地添加更多功能的一种方式。装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊的行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象。这样做的好处是有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。 示例代码抽象构件类 Component 123456789package com.example.decoratorPattern;/** * 装饰模式：抽象构建对象 * Created by Administrator on 2017/4/17. */public interface Component &#123; public void operation();&#125; 具体构建类 ConcreteComponent 1234567891011121314package com.example.decoratorPattern;/** * 装饰模式：具体构建对象 * * @author pengdh * @date: 2017-04-17 23:02 */public class ConcreteComponent implements Component &#123; @Override public void operation() &#123; System.out.println("具体对象操作"); &#125;&#125; 装饰类 Decorator 123456789101112131415161718192021package com.example.decoratorPattern;/** * 装饰模式：装饰对象 * * @author pengdh * @date: 2017-04-17 23:06 */public abstract class Decorator implements Component&#123; private Component component; public Decorator(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; // 委派给构建 component.operation(); &#125;&#125; 具体装饰类A ConcreteDecotorA 12345678910111213141516171819202122package com.example.decoratorPattern;/** * 装饰模式：具体装饰对象A * * @author pengdh * @date: 2017-04-17 23:10 */public class ConcreteDecotorA extends Decorator &#123; // 本类的独有功能，区别于 ConcreteDecotorB private String addedState; public ConcreteDecotorA(Component component) &#123; super(component); &#125; @Override public void operation() &#123; super.operation(); addedState = "New State"; System.out.println("具体装饰对象A的操作"); &#125;&#125; 具体装饰类B ConcreteDecotorB 123456789101112131415161718192021222324252627package com.example.decoratorPattern;/** * 装饰模式：具体装饰对象B * * @author pengdh * @date: 2017-04-17 23:15 */public class ConcreteDecotorB extends Decorator &#123; public ConcreteDecotorB(Component component) &#123; super(component); &#125; @Override public void operation() &#123; super.operation(); addedBehavior(); System.out.println("具体装饰对象B的操作"); &#125; /** * 本类独有的方法，以区别于ConcreteDecotorB */ private void addedBehavior() &#123; &#125;&#125; 客户端测试类 TestDecotorPattern 1234567891011121314151617181920212223package com.example.decoratorPattern;/** * 装饰模式：客户端测试类 * * @author pengdh * @date: 2017-04-17 23:19 */public class TestDecotorPattern &#123; /** * 装饰的方法是：首先用 ConcreteComponet 实例化对象 c ， * 然后用 ConcreteDecoterA 的实例化对象 d1 来包装 c , * 再用 ConcreteDecoterB 的实例化对象 d2 来包装 d1 , * 最终执行 d2 的operation()方法 * @param args */ public static void main(String[] args) &#123; ConcreteComponent c = new ConcreteComponent(); ConcreteDecotorA d1 = new ConcreteDecotorA(c); ConcreteDecotorB d2 = new ConcreteDecotorB(d1); d2.operation(); &#125;&#125; 简单的装饰模式如果只有一个 ConcreteComponent 类，可以考虑去掉抽象的 Component 类（接口），把 Decorator 作为一个 ConcreteComponent 子类。如果只有一个 ConcreteDecorator 类，那么就没有必要建立一个单独的 Decorator 类，而可以把 Decorator 和 ConcreteDecorator 的责任合并成一个类。甚至在只有两个 ConcreteDecorator 类的情况下，都可以这样做。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（三）：设计模式六大原则]]></title>
      <url>%2F2017%2F04%2F10%2Fdesign-pattern-six-principle%2F</url>
      <content type="text"><![CDATA[设计模式有六大原则 单一职责原则（Single Responsibility Principle,SRP） 开闭原则（Open-Closed Principle,OCP） 里氏替换原则（Liskov Substitution Principle,LSP） 依赖倒置原则（Dependency Inversion Principle,DIP） 接口隔离原则（Interface Segregation Principle,ISP） 迪米特法则（Law of Demeter,LoD） 单一职责原则单一职责原则（Single Responsibility Principle,SRP）：就一个类而言，应该仅有一个引起它变化的原因。即一个类应该只负责一个功能领域中的相应职责。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 开闭原则开闭原则（Open-Closed Principle,OCP）： 是指软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。即软件实体应该尽量在不修改原有代码的情况下进行扩展。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。 里氏替换原则里氏替换原则（Liskov Substitution Principle,LSP）：所有引用父类的地方必须能够透明的使用子类的对象。即子类型必须能够替换掉它们的父类型。 里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。同时，里氏代换原则是实现开闭原则的重要方式之一。 依赖倒置原则依赖倒置原则（Dependency Inversion Principle,DIP）：抽象不应该依赖细节，细节应该依赖于抽象。即应该针对接口编程，而不是针对实现编程。 在大多数情况下，我们会同时使用开闭原则、里氏代换原则和依赖倒转原则，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。 接口隔离原则接口隔离原则（Interface Segregation Principle,ISP）：使用专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。 迪米特法则迪米特法则（Law of Demeter,LoD）：一个软件实体应当尽可能少地与其它实体发生相互作用。 迪米特法则又称为最少知识原则（LeastKnowledge Principle,LIP）。如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 参考资料http://www.cnblogs.com/dolphin0520/p/3919839.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在 java 泛型中 K T V E 等的代表含义]]></title>
      <url>%2F2017%2F04%2F07%2Fjava-generic-type%2F</url>
      <content type="text"><![CDATA[K ： Key（健，常在集合中使用） V ： Value（值，常在集合中使用） E ： Element（元素，常在集合中使用） T ： Type（类型，常代表 java 类） ? ： 表示不确定的 java 类型（无限制通配符类型） N ： Number（数值类型） S、U、V ： 2nd、3rd、4th types Object ： java 中所有类的父类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git 常用操作命令]]></title>
      <url>%2F2017%2F04%2F06%2Fgit-operator%2F</url>
      <content type="text"><![CDATA[本篇文章旨在记录一些常用的 Git 命令，会随着工作过程不断的更新。 git remote123456789git remote 命令列出所有远程主机git remote -v 可查看远程主机的网址git remote show &lt;主机名&gt; 查看该主机的详细信息git remote add 用于添加远程主机git remote set-url origin [url] 修改远程仓库地址git remote rm 删除远程主机git remote rename 重命名远程主机git remote set-url --add origin &lt;url2,3,4...&gt; 添加多个地址到远程库 git fetch默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。它取回的代码对你本地的开发代码没有影响，所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。123git fetch &lt;远程主机名&gt; &lt;分支名&gt;git fetch origin &amp;&amp; git reset –hard origin/master 拉取远程代码并且覆盖本地更改 git branch1234567891011121314git branch -r 查看远程分支git branch -a 查看所有分支git branch [branch-name] 新建一个分支，但依然停留在当前分支git checkout -b [branch] 新建一个分支，并切换到该分支git branch [branch] [commit] 新建一个分支，指向指定commitgit branch --track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系git checkout - 切换到上一个分支git cherry-pick [commit] 选择一个commit，合并进当前分支git branch -d [branch-name] 删除分支git push origin --delete [branch-name] 删除远程分支git merge &lt;分支名&gt; 合并分支git rebase &lt;分支名&gt; 合并分支git revert -m 1 xxxx 回滚一个 merge git pullgit pull 命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并12git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; git push12git push origin master -f 强制推送远程分支git push --force origin master 强制推送远程分支 git stash123456789git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存git stash save &quot;message...&quot; 这条命令实际上是上一条 git stash 命令的完整版git stash list 显示进度列表.git stash pop [--index] [&lt;stash&gt;] 如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。如果提供参数（来自 git stash list 显示的列表），则从该 &lt;stash&gt; 中恢复。恢复完毕也将从进度列表中删除 &lt;stash&gt;。git stash apply [--index] [&lt;stash&gt;] 除了不删除恢复的进度之外，其余和 git stash pop 命令一样git stash clear 删除所有存储的进度 撤销 Git 的最后一次提交12git reset –soft HEAD~1 修改之前的提交记录或者很久前提交的记录 git rebase –interactive ID^将需要修改的记录的 pick 改成 edit执行更改git commit –all –amendgit rebase –continue 使用多个远程代码库，并且使用多个不同的 SSH Key 修改 ~/.ssh/config Host bitbucket.orgHostName bitbucket.orgPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaUser git Host bitbucket.org-key2HostName bitbucket.orgIdentityFile ~/.ssh/key2_id_rsaUser git 修改 .git/config [remote “origin”]url = git@bitbucket.org-key2:XXXX/yyyy.gitfetch = +refs/heads/:refs/remotes/origin/ 和外部团队协作需要的维护多个远程库，合并其他库的更新的过程 git remote rename origin upstreamgit remote add origin URL_TO_GITHUB_REPOgit push origin mastergit pull upstream master &amp;&amp; git push origin master git 忽略规则 .a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/.txt # 会忽略 doc/notes.txt 但不包括 doc/server/notes.txt 修改 .gitignore 规则不生效解决办法原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： git rm -r –cached .git add .git commit -m ‘update .gitignore’]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（一）：简单工厂模式]]></title>
      <url>%2F2017%2F03%2F27%2Fsimple-factory-pattern%2F</url>
      <content type="text"><![CDATA[简单工厂模式(simple factory pattern)简单工厂模式(simple factory pattern)：属于对象的创建方式。就是说我们考虑使用一个单独的类来处理类的实例化。例如，对于一个计算器，只需要考虑输入数字和运算符工厂就可以实例化出适合的对象计算出结果。 简单工厂模式UML图 示例代码运算类 Operation：用于计算结果。申明两个变量 numberA、numberB 用于记录需要计算的两个数，定义一个getResult()方法，用于获取计算结果。 123456789101112131415161718192021222324252627282930313233package com.example.simpleFactoryPattern;/** * 运算类 * * @author pengdh * @date: 2017-03-15 22:44 */public class Operation &#123; protected double numberA; protected double numberB; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; public double getResult() &#123; double result = 0; return result; &#125;&#125; 加法运算类 OperationAdd：继承运算类，用于加法运算 12345678910111213141516package com.example.simpleFactoryPattern;/** * 加法运算类 * * @author pengdh * @date: 2017-03-15 23:19 */public class OperationAdd extends Operation &#123; @Override public double getResult() &#123; double result = 0; result = numberA + numberB; return result; &#125;&#125; 减法运算类 OperationSub：继承运算类，用于减法运算 12345678910111213141516package com.example.simpleFactoryPattern;/** * 减法运算类 * * @author pengdh * @date: 2017-03-15 23:24 */public class OperationSub extends Operation &#123; @Override public double getResult() &#123; double result = 0; result = numberA - numberB; return result; &#125;&#125; 乘法运算类 OperationMul：继承运算类，用于乘法运算 12345678910111213141516package com.example.simpleFactoryPattern;/** * 乘法运算类 * * @author pengdh * @date: 2017-03-15 23:27 */public class OperationMul extends Operation &#123; @Override public double getResult() &#123; double result = 0; result = numberA * numberB; return result; &#125;&#125; 除法运算类 OperationDiv：继承运算类，用于除法运算 12345678910111213141516package com.example.simpleFactoryPattern;/** * 除法运算类 * * @author pengdh * @date: 2017-03-15 23:30 */public class OperationDiv extends Operation &#123; @Override public double getResult() &#123; double result = 0; result = numberA / numberB; return result; &#125;&#125; 工厂类 OperationFactory：根据输入的运算符，通过多态来创建适合的计算对象实现计算结果。 12345678910111213141516171819202122232425262728package com.example.simpleFactoryPattern;/** * 运算工厂类 * * @author pengdh * @date: 2017-03-15 23:35 */public class OperationFactory &#123; public static Operation createOperate(String operate) &#123; Operation oper = null; switch (operate) &#123; case "+": oper = new OperationAdd(); break; case "-": oper = new OperationSub(); break; case "*": oper = new OperationMul(); break; case "/": oper = new OperationDiv(); break; &#125; return oper; &#125;&#125; 客户端测试类 OperationTest 123456789101112131415161718package com.example.simpleFactoryPattern;/** * 运算测试类 * * @author pengdh * @date: 2017-03-16 0:16 */public class OperationTest &#123; public static void main(String[] args) &#123; Operation oper = new Operation(); oper = OperationFactory.createOperate("+"); oper.numberA = 3; oper.numberB = 1; double result = oper.getResult(); System.out.println("-----------pengdh----------- result = " + result + "," + "当前类 = OperationTest.main()"); &#125;&#125; 以上通过 OperationFactory 工厂类来管理计算对象。这样如果有新的计算方法就不用再去原有的计算对象。例如，新加一个乘方运算，只需要新增一个继承运算类的乘方运算类，然后在工厂类新增一个乘方分支就可以了。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UML类图]]></title>
      <url>%2F2017%2F03%2F25%2Fuml-exmaple%2F</url>
      <content type="text"><![CDATA[今天看大话设计模式的时候一时兴起就用visio把UML类图画了一遍以加深下印象。 我们使用矩形框代表一个类，类图分为三层，第一层表示类名称，如果是抽象类就用斜体表示，如果是接口的话顶端会有 &lt;&gt; 显示，或者像图中唐老鸭那样的棒棒糖表示法；第二层表示类的特性，通常就是累的字段和属性；第三层表示类的操作，通常是类的方法或者行为，‘+’表示 public，‘-’表示 private，‘#’表示 protected。 类与类之间有如下关系： 泛化：表示类与类之间的继承关系、接口与接口之间的继承关系； 实现：表示类对接口的实现； 依赖：当类与类之间有使用关系时就属于依赖关系，不同于关联关系，依赖不具有“拥有关系”，而是一种“相识关系”，只在某个特定地方（比如某个方法体内）才有关系。 关联：表示类与类或类与接口之间的依赖关系，表现为“拥有关系”；具体到代码可以用实例变量来表示； 聚合：属于是关联的特殊情况，体现部分-整体关系，是一种弱拥有关系；整体和部分可以有不一样的生命周期；是一种弱关联； 组合：属于是关联的特殊情况，也体现了体现部分-整体关系，是一种强“拥有关系”；整体与部分有相同的生命周期，是一种强关联；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读 Effective Java 的一点收获]]></title>
      <url>%2F2017%2F03%2F18%2Feffective-java%2F</url>
      <content type="text"><![CDATA[2017年阅读完的第一本书是号称Java四大名著之一，被Java之父 James Gosling 赞誉有佳的 Effective java 中文版（第2版） ，并把代码敲了一遍，受益匪浅。书中的78条程序猿必备经验法则可以说是条条经典，我是第一遍阅读这本书，相信以后有时间我还会重新再读第二遍或会多读几遍。对于我个人而言最大的收获是在我日常开发中对代码的规范性和代码逻辑处理上收获颇多，特别是日常开发中容易忽略的一些缺陷和坑。对于代码规范性而言，主要指代码格式和层次上，规范的代码格式及层次分明的代码让人看起来会有一种赏心悦目的感觉。对于代码逻辑上，我记得以前写代码总喜欢一个方法走到黑，比较少会考虑代码的健壮性及一些好的方法思想的使用，现在会更多的思考一些高效的写法。电子书籍分享到 百度云盘 上，示例源代码分享到 github 上，有需要的童鞋，欢迎下载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用的 maven 仓库镜像]]></title>
      <url>%2F2017%2F03%2F04%2Fmaven-repository%2F</url>
      <content type="text"><![CDATA[目前我们开发的项目中最常见的是使用maven来管理的。下面整理一些常用的 maven 仓库镜像。配置方法是在 maven 的 settings.xml 文件里配置 mirrors 的子节点 mirror 节点。 阿里云（国内首推）123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; repo2123456&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; uk123456&lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; ibiblio123456&lt;mirror&gt; &lt;id&gt;ibiblio&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url&gt; &lt;/mirror&gt; jboss123456&lt;mirror&gt; &lt;id&gt;jboss-public-repository-group&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;JBoss Public Repository Group&lt;/name&gt; &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式（二）：策略模式]]></title>
      <url>%2F2017%2F03%2F03%2Fstrategy-pattern%2F</url>
      <content type="text"><![CDATA[策略模式（strategy pattern）策略模式（strategy pattern）：属于对象的行为模式。策略模式定义了一系列的算法，并将每个算法封装起来，让他们之间可以相互转换，该模式让算法的变化，不会影响到使用算法的客户。 策略模式UML图策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：准备一组算法，并将每一个算法封装起来，使得它们可以互换。 策略模式涉及到的三个角色：环境(Context)角色：该角色中实现了对抽象策略中定义的接口或者抽象类的引用。抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 策略模式的意义：从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合，低耦合的特性使软件具有更强的可扩展性，易于维护；更重要的是，它大大提高了软件的可重用性。 示例代码抽象策略接口 Strategy 123456789101112package com.example.strategyPattern;/** * 策略模式：抽象策略类 * Created by Administrator on 2017/3/30. */public interface Strategy &#123; /** * 算法方法 */ public void algorithmInterface();&#125; 具体算法类A ConcreteStrategyA 1234567891011121314package com.example.strategyPattern;/** * 策略模式：具体算法A * * @author pengdh * @date: 2017-03-30 23:28 */public class ConcreteStrategyA implements Strategy &#123; @Override public void algorithmInterface() &#123; System.out.println("算法A实现"); &#125;&#125; 具体算法类B ConcreteStrategyB 1234567891011121314package com.example.strategyPattern;/** * 策略模式：具体算法B * * @author pengdh * @date: 2017-03-30 23:31 */public class ConcreteStrategyB implements Strategy &#123; @Override public void algorithmInterface() &#123; System.out.println("算法B实现"); &#125;&#125; 具体算法类C ConcreteStrategyC 1234567891011121314package com.example.strategyPattern;/** * 策略模式：具体算法C * * @author pengdh * @date: 2017-03-30 23:32 */public class ConcreteStrategyC implements Strategy &#123; @Override public void algorithmInterface() &#123; System.out.println("算法C实现"); &#125;&#125; 环境类 Context 123456789101112131415161718192021222324package com.example.strategyPattern;/** * 环境角色类 * * @author pengdh * @date: 2017-03-30 23:34 */public class Context &#123; // 申明一个抽象的策略对象 private Strategy strategy; // 构造函数，传入一个具体的策略对象 public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 策略方法 */ public void contextInterface() &#123; strategy.algorithmInterface(); &#125;&#125; 客户端测试类 TestStrategyPattern 12345678910111213141516171819202122package com.example.strategyPattern;/** * 策略模式测试类 * * @author pengdh * @date: 2017-03-30 23:39 */public class TestStrategyPattern &#123; public static void main(String[] args) &#123; Context context; context = new Context(new ConcreteStrategyA()); context.contextInterface(); context = new Context(new ConcreteStrategyB()); context.contextInterface(); context = new Context(new ConcreteStrategyC()); context.contextInterface(); &#125;&#125; 策略模式的使用场景例如超市或者商场会不定期的搞一些促销活动，活动分为多种形式，如针对不同商品的折扣力度不一样，有的打八折，有的五折；另外一些又使用满减的方式，如满300减100。而且这类的促销活动每次都不是固定的。针对这种场景我们就可以使用策略模式。 策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。 策略模式的优点（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 （2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 策略模式的缺点（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 （2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。 参考文献 大话设计模式 http://www.cnblogs.com/java-my-life 源码地址：https://github.com/alexpdh/bigTalkDesignPattenSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Intellij IDEA 使用技巧（一）安装和激活]]></title>
      <url>%2F2017%2F02%2F25%2FIntellij-IDEA-course01%2F</url>
      <content type="text"><![CDATA[前言一直很想学习了解idea，今天来了兴趣，试着安装和激活了idea。我本人使用的编程语言是Java，以前一直使用的IDE是Eclipse和myeclipse。这篇文章参考了网上了一些资料对idea的安装激活步骤做点总结。 安装环境：Windows 10 安装方式：Toolbox App 安装版本：2016.3.4 旗舰版(Ultimate) idea简介IntelliJ IDEA 主要用于支持 Java、Scala、Groovy 等语言的开发工具，同时具备支持目前主流的技术和框架，擅长于企业应用、移动应用和 Web 应用的开发。官方网站https://www.jetbrains.com/idea/。版本分为社区版(Community)和旗舰版(Ultimate)，社区办只提供了一些基本的功能，比旗舰版少很多功能。安装我电脑是 Windows 环境，我安装方式是通过jetbrains的Toolbox来安装的，这种安装方式有一个好处就是toolbox可以管理jetbrains的所有产品的安装，如果安装的产品有更新，能够通过toolbox来更新相应的产品。1、到下载页面下载安装toolbox传送门(toolbox下载页面)2、运行并设置toolboxtoolbox下安装的软件默认都是安装的C盘的，我们可以自己更改安装目,点击右上方的设置按钮进入设置界面在install localtion下点击select…选择安装目录3、软件安装安装目录设置完了后，返回All tools界面在对应的产品后点击install下对应的软件版本进行安装：4、激活idea我们安装的是idea旗舰版，这个版本是需要付费使用的，而且还小贵，找了个注册码有效期为2016年11月24日至2017年11月23日，运行idea输入注册码： 1BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK/3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL/oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw/sCltpoPWlJtDOcw/iEWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 5、常用目录设置idea常常修改的文件一般在bin目录下的几个文件，下面介绍几个常用的文件： IntelliJ IDEA 的安装目录并不复杂，上图为最常改动的 bin 目录，经常会改动的文件或是必须介绍就是如图红色框中的几个。 idea.exe 文件是 IntelliJ IDEA 32 位的可行执行文件，IntelliJ IDEA 安装完默认发送到桌面的也就是这个执行文件的快捷方式。 idea.exe.vmoptions 文件是 IntelliJ IDEA 32 位的可执行文件的 VM 配置文件，具体配置修改会下面进行专门讲解。 idea64.exe 文件是 IntelliJ IDEA 64 位的可行执行文件，要求必须电脑上装有 JDK 64 位版本。64 位的系统也是建议使用该文件。 idea64.exe.vmoptions 文件是 IntelliJ IDEA 64 位的可执行文件的 VM 配置文件，具体配置修改会下面进行专门讲解。idea.properties 文件是 IntelliJ IDEA 的一些属性配置文件，具体配置修改会下面进行专门讲解。 不管你使用的是哪个操作系统，IntelliJ IDEA 的设置目录命名是统一的、有规律：.IntelliJ IDEA16。其中 16 表示大版本号，如果你电脑上还同时装有 15 的版本，那则还应该会有一个：.IntelliJ IDEA15 的设置目录，其他版本道理一样。 在三大主流的操作系统上，你只要对整个硬盘进行搜索：.IntelliJ IDEA16，即可找到，无需可以去记忆到底生成在哪个目录下。 对于这个设置目录有一个特性，就是你删除掉整个目录之后，重新启动 IntelliJ IDEA 会再自动帮你再生成一个全新的默认配置，所以很多时候如果你把 IntelliJ IDEA 配置改坏了，没关系，删掉该目录，一切都会还原到默认，我是很建议新人可以多自己摸索 IntelliJ IDEA 的配置，多几次还原，有助于加深对 IntelliJ IDEA 的了解。 config 目录是 IntelliJ IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。也是我个人认为最重要的目录，没有之一，如果你还记得安装篇的介绍的时候，安装新版本的 IntelliJ IDEA 会自动扫描硬盘上的旧配置目录，指的就是该目录。这个目录主要记录了：IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等等个性化的设置。 system 目录是 IntelliJ IDEA 系统文件目录，是 IntelliJ IDEA 与开发项目一个桥梁目录，里面主要有：缓存、索引、容器文件输出等等，虽然不是最重要目录，但是也是最不可或缺目录之一。 个性化设置 上图是 64 位可执行文件的 JVM 配置文件内容，如果你是 32 位的系统你应该修改的是 idea.exe.vmoptions 文件里面的内容，但是由于 32 位系统内存一般都是 2G 左右的，所以也没有多大空间可以调整，所以一般无需调整的。 修改的原则主要是根据自己机器的内存情况来判断的，我个人是建议 8G 以下的机子或是静态页面开发者都是无需修改的。如果你是开发大型项目、Java 项目或是 Android 项目，并且内存大于 8G，建议进行修改，常修改的就是下面 4 个参数，我这里主要以我的机子会例进行建议，每个人机子情况不一，这里也只是做一个引子，最好的调整方式是你可以根据 jconsole 这类工具进行观察后个性化调整。 -Xms128m，16 G 内存的机器可尝试设置为 -Xms512m -Xmx750m，16 G 内存的机器可尝试设置为 -Xmx1500m -XX:MaxPermSize=350m，16G 内存的机器可尝试设置为 -XX:MaxPermSize=500m -XX:ReservedCodeCacheSize=225m，16G 内存的机器可尝试设置为 -XX:ReservedCodeCacheSize=500m 上图是 IntelliJ IDEA 一些属性配置，没有 32 位和 64 位之分，修改原则主要根据个人对 IntelliJ IDEA 的个性化配置情况来分析。常修改的就是下面 4 个参数： idea.config.path=${user.home}/.IntelliJIdea/config，该属性主要用于指向 IntelliJ IDEA 的个性化配置目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。 idea.system.path=${user.home}/.IntelliJIdea/system，该属性主要用于指向 IntelliJ IDEA 的系统文件目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。如果你的项目很多，则该目录会很大，如果你的 C 盘空间不够的时候，还是建议把该目录转移到其他盘符下。 idea.max.intellisense.filesize=2500，该属性主要用于提高在编辑大文件时候的代码帮助。IntelliJ IDEA 在编辑大文件的时候还是很容易卡顿的。 idea.cycle.buffer.size=1024，该属性主要用于控制控制台输出缓存。有遇到一些项目开启很多输出，控制台很快就被刷满了没办法再自动输出后面内容，这种项目建议增大该值或是直接禁用掉，禁用语句 idea.cycle.buffer.size=disabled。启动idea安装完成后可以启动idea了：下载插件可以通过file-&gt;Setting-&gt;Plugins 去下载各种插件参考文档 https://github.com/judasn/IntelliJ-IDEA-Tutorial http://blog.lanyus.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017目标书单]]></title>
      <url>%2F2017%2F02%2F18%2F2017-reading-plan%2F</url>
      <content type="text"><![CDATA[2017年小目标——目标书单。 技术类 《Effective java 中文版（第2版）》 《深入理解Java虚拟机（第2版）》 《Java并发编程实战》 《实战Java高并发程序设计》 《Spring源码深度解析》 《大话设计模式》 《大话数据结构》 《Redis实战》 其它书籍 《人类简史》 《未来简史》 《解忧杂货店》 《怪人们》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记一次生产环境因jdk的bug导致的异常]]></title>
      <url>%2F2017%2F02%2F11%2Fjdkbug%2F</url>
      <content type="text"><![CDATA[最近生产环境每隔一段时间会抛一个异常： 12345678Exception in thread "main" javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,1] Message: JAXP00010001: The parser has encountered more than "64000" entity expansions in this document; this is the limit imposed by the JDK. at com.sun.org.apache.xerces.internal.impl.XMLStreamReaderImpl.setInputSource(XMLStreamReaderImpl.java:219) at com.sun.org.apache.xerces.internal.impl.XMLStreamReaderImpl.&lt;init&gt;(XMLStreamReaderImpl.java:189) at com.sun.xml.internal.stream.XMLInputFactoryImpl.getXMLStreamReaderImpl(XMLInputFactoryImpl.java:277) at com.sun.xml.internal.stream.XMLInputFactoryImpl.createXMLStreamReader(XMLInputFactoryImpl.java:129) at com.sun.xml.internal.stream.XMLInputFactoryImpl.createXMLEventReader(XMLInputFactoryImpl.java:78) at Main.main(Main.java:38) 元宵节快乐 在讨论问题之前来点题外话，今天是中国传统佳节-元宵节，祝大家元宵节快乐。在上周播出的歌手中。赵雷的一首《成都》彻底火了，同时故事中描述的 “走到玉林路的尽头，坐在小酒馆的门口” 中的小酒馆也火了，由于我现在住的地方离小酒馆比较近（大概半小时路程），于是今天一个人走到了玉林路口的尽头看到了歌中说的小酒馆，门口拍照的人源源不断，走进小酒馆里在白天的情况下居然满座，经营小酒馆的是一对夫妇，老板看起挺朴实的，老板娘大着肚子和丈夫一起忙前忙后。老板给我找了个拼桌的位置坐下要了瓶啤酒坐下，屋里只放赵雷的歌。比起七八十年代，什么事物在互联网信息时代下蹿红的速度相当惊人。 回到正题异常的大概意思是“解析器解析xml文档时文档实体扩展个数超过了 “640000” 个”，抛这个异常的是我们的一个专门接收中音给我们分发音乐素材的程序。系统采用的是基于CXF的WebService接口程序。有用基于SOAP传输的xml形式的接口数据，也有rest设计传输的json格式的数据。不过报的这个异常是xml形式的接口抛出来的,它限制了在读取xml文档时共享实体的个数不能大于640000个，影响的jdk版本有 5.0u55，6u65，7u45，8 12345678910111213141516171819import java.io.ByteArrayInputStream; import javax.xml.stream.XMLInputFactory; public class Main &#123; public static void main(String[] args) throws Exception &#123; String xml = "&lt;?xml version=\"1.0\"?&gt;&lt;test&gt;&lt;/test&gt;"; XMLInputFactory factory = XMLInputFactory.newInstance(); for (int i = 0; i &lt; 64001; i++) &#123; ByteArrayInputStream stream = new ByteArrayInputStream(xml.getBytes()); factory.createXMLEventReader(stream); &#125; &#125;&#125; 我们服务器的jdk版本刚好是这个版本的。这个bug在 1.7.0_51 版本之后得到的修复，因此只需将jdk版本升级到 1.7.0_51 之后的版本就可以解决这个问题了。下面是官网上对这个bug描述。https://bugs.openjdk.java.net/browse/JDK-8028111]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记一次http接口调试问题]]></title>
      <url>%2F2017%2F02%2F05%2Fhttp-Garbled%2F</url>
      <content type="text"><![CDATA[在开发工程中，我们经常会遇到和其它第三方厂家有接口数据来往的情况。这是一次我们作为客户端去获取另一个厂家推流的直播地址的接口，这个接口情况有些不一样，我们需要在一个接口中封装两次http请求，大概场景是这样的：第一次调用方式是POST，第二次是Get，第一次调用会获取到一个地址，返回结果类似这样的：1234567&#123; "resultcode": "0", "desc": "配置url成功", "playurl": "http://xxx.xxx.cn:1100/pushUserInfo/v1/7+MbU0JGqdzxR4r9WppYdwgiEBj1vS3sjmIJGKzyd1Uo7Aiw8n5TGdmmh+6t7v1caKu15I+WJKsQRZzQ3rtT519E0R9pO4XHygB+bx0irIFIhuLVREDEOS0+OKpwcFWrIVRTurT8nTEdB8LACa5KifWfUPB6Emm5grPgROocpTZIWoo7c78ezILqwAMZ4flghHLSoucOW6S/OO86fUfNxg==/3006686669_52.mp4.m3u8?ec=1/type=aepadapter/fixed/ip/hls/config2016-8-25 18-441"&#125; 这里获取到接口返回一个带参数的地址，这里注意一下，这个地址里有些特殊符号，如：下划线、等号之类的等等。我们还需要将返回的这个带参数的URL地址作为第二个请求的URL，并携带上第二个请求播放接口要求的请求参数使用get方式调用接口请求从而获取到一个重定向的地址，请求地址类似这样的：12http://xxx.xxx.com/pushUserInfo/v1/7Jo8ty86AUKmr6fTuRYQ6Ylf+YaMXYF6GTPPWPchbvvIMG9MADvMOQtk9pOF0VjDSBuMxDZ4TPap2G5uhoCuurjoLwyNhbaPxV0T4XJFUK4CRUlwskU5eA4ImCjdv06plhYlvEeHW+IEASnEbvRhnuwJSXJUDfm8XTScBLnyuDEyTmPlrZTRwoUqFH7Bri8i0pW1M0OlpjB8fzWjTudRiA==/3006686669_52.mp4.m3u8?ec=1/type=aepadapter/fixed/ip/hls/config0&amp;Id_type=1&amp;userid=15000000000&amp;ipaddress=10.1.1.1 HTTP/1.1 http返回码应该是302，这个地址才是真正的播放地址，其实是一个m3u8的播放流。对方通过这样的一个地址进行推流播放。很快这个接口封装好了，自己写了个单元测试进行调用测试；在做单元测试的过程中发现最终的返回码是200，而且响应的报文是空的，什么信息都没有。正常应该是返回302，单独测试第一个接口的时候响应是正常的，测试第二个的时候出问题了，反复确认封装的请求参数是没有问题的，开始怀疑是对方响应有问题。后来我单独用第一个返回的地址带上参数在浏览器中请求是可以的，于是知道大概是URL被转码了的原因，因为第一个接口返回的地址是带了参数的，如上面参数里有很多特殊字符。我在请求的时候自己封装了一个httpclient工具类，里面有封装的带参数的get方法是这样写的：123456789101112131415public static String httpGetRequest(String url, Map&lt;String, Object&gt; params)&#123; String result=EMPTY_STR; URIBuilder ub = new URIBuilder(); ub.setPath(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); ub.setParameters(pairs); try&#123; HttpGet httpGet = new HttpGet(ub.build()); result = getResult(httpGet); &#125;catch(URISyntaxException e)&#123; e.printStackTrace(); &#125; return result; &#125; 这里在构造请求时使用的是 java.net.URI 来构造的，而经过查询，从jdk的一个bug回复中知道：JDK-8132508 : Bug JDK-8029354 reproduces with underscore in hostname123RFC 952 disallows _ underscores in hostnames. So, this is not a bug. I also haven&apos;t been able to find examples of actual usage.So, unless a particularly compelling case can be made, I&apos;m closing as not a bug. 说明了java.net.URI 的域名只能由 字母 (A-Z), 数字(0-9), 减号 (-), 和 点 (.) 组成。也就是说 java.net.URI 验证了 hostname。同时也看到了在 java.net.URL 中不会做这个验证。所以问题找到了，所以我们把这个方法换成其它方式来构造就正常返回了。12345678910111213141516171819private static String createParamUrl(String url, Map&lt;String, Object&gt; params) &#123; Iterator&lt;String&gt; it = params.keySet().iterator(); StringBuilder sb = new StringBuilder(); boolean isIncludeQuestionMark =url.contains("?"); if (!isIncludeQuestionMark) &#123; sb.append("?"); &#125; while (it.hasNext()) &#123; String key = it.next(); String value = (String) params.get(key); sb.append("&amp;"); sb.append(key); sb.append("="); sb.append(value); &#125; url += sb.toString(); return url; &#125; 赞同提交bug的网友的意见，这样会隐藏很多的坑。为什么一个验证了域名一个却不做验证。我们也看到bug提交之后得到回复这不是一个bug。 参考文献 https://www.tanglei.name/blog/conflicts-between-java-net-url-and-java-net-uri-when-dealing-with-hostname-contains-underscore.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于hexo+GitHub搭建个人博客（二）进阶]]></title>
      <url>%2F2017%2F01%2F15%2Fhexo-blog-building02%2F</url>
      <content type="text"><![CDATA[上篇文章介绍了hexo+GitHub搭建及一些基本优化，这篇文章主要介绍域名的绑定、第三方服务的添加 个人域名绑定GitHub默认使用的是对应的xxx.github.io的一个二级域名，想要给个性一点的话可以自己购买一个域名绑定。 域名购买域名购买平台很多，国内阿里的万网，百度的百度云,下血本在百度买了个.com域名（[白眼]主要是刚好百度云在搞活动）。购买了之后需要实名认证之后才可以正式使用，一般两天内可以通过。 域名解析认证通过后，我们就可以做域名解析了： 先在Git bash或者doc窗口下 ping下自己的GitHub的地址（我的就是 alexpdh.github.io）获取到对应的ip地址。 登陆百度云，选择【产品服务】-&gt;【域名服务】-&gt;【域名管理】，点击域名后【操作】下的解析，点击【添加解析】 主机记录可以添加三种域名前缀，想不想要www自己选择www：解析后域名为 www.baidubceyun.cn@：直接解析主域名 baidubceyun.cn：泛解析，匹配其他所有域名 .baidubceyun.cn 接下来在你hexo的的source目录下新建一个文件命名为CNAME没有后缀，打开将解析的域名添加到文件里，如果你上面配置的是www前缀的域名，这里就填写 www.xxx.com，对应就访问http://www.xxx.com ；如果配置的是@，这里填写 xxx.com，对应访问 http://xxx.com ；自由选择。 添加好之后用部署三步骤部署到GitHub，打开浏览器输入自己的域名访问。 添加第三方服务添加多说评论 注册并登陆多说，点击【我要安装】填写对应的创建站点的信息。 创建完成后，修改themes/_config.yml文件，把 duoshuo_shortname 改成之前设置的，就是.duoshuo.com前面那个二级域名 12# Duoshuo ShortNameduoshuo_shortname: alexpdh 添加百度统计 注册并登陆百度统计添加网站完成后，选择【管理】-&gt;【代码管理】-&gt;【代码获取】，复制统计脚本id 创建完成后，修改themes/_config.yml文件，添加 baidu_analytics 字段，把值设置成自己的脚步id 12# Baidu Analytics IDbaidu_analytics: 9dc06432cf936b467fbc1592bb73673d 添加 Swiftype 站内搜索 注意：新注册的swiftype账号过了试用期后就不能继续使用搜索服务了，老账号任然可以继续使用，可以使用 Local Search 配置很简单，参照next文档配置即可 注册并登陆Swiftype,创建一个新的搜索引擎 点击 Install Swiftype Search 获取key 创建完成后，修改themes/_config.yml文件，添加 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key 12# Swiftype Search API Keyswiftype_key: SELpQxw29CqCcMWn6235 其他设置 其他设置比如侧边栏、友情链接、菜单栏等请参考next主题配置教程插入七牛云图片 注册七牛云 登陆七牛云后选择【对象存储】-&gt;【新建存储空间】 进入创建的存储空间选择【内容管理】-&gt;【上传文件】选择要上传的文件，完成后关闭，然后点击对应图片【操作】下…【复制外链】 在你文章里需要图片处使用如下语法插入图片1![logo](复制七牛云的外链接) 自此，我们基本完成了整个hexo博客的搭建，有兴趣再继续优化的同学可以继续参考网上对应的文档进行优化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于hexo+GitHub搭建个人博客]]></title>
      <url>%2F2017%2F01%2F09%2Fhexo-blog-building%2F</url>
      <content type="text"><![CDATA[本博客是基于Hexo+GitHub在Windows 10（64位）环境下搭建的，搭建前默认有GitHub账号并会基本的Git命令，如果没有请先自行了解学习。 环境准备 Windows 10（64位） Git-2.11.0-64-bit.exe node-v6.9.3-x64.msi 安装GitGit是连接本地和GitHub的桥梁，你可以直接在本地将代码上传到GitHub，下载地址：https://git-for-windows.github.io/。验证是否安装成功，输入： 1git --version 安装nodehexo是用node.js写的，所以需要安装node，下载地址：https://nodejs.org/en/，验证是否安装成功，输入： 1node -v 安装Hexo 安装hexo前要注意一点，我在这里被坑了不少时间，npm全称Node Package Manager，是node.js的模块依赖管理工具。由于npm的源在国外，所以国内用户使用起来各种不方便，我在安装下载hexo时甚至出现链接断开的现象，我们可以使用国内的镜像源，常用的就是淘宝的npm镜像，如何使用呢？ 一个一劳永逸的方法 打开Git bash，输入： 12345npm config set registry https://registry.npm.taobao.org// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info express 参考 国内优秀npm镜像 安装hexo命令在本地新建一个文件夹随便命名，如：hexo，打开git bash，切换到新建的文件夹下面输入： 123npm install hexo-cli -g ###安装hexo命令hexo init ###部署hexo，初始化命令npm install ###安装插件命令 几个常用的hexo插件 12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 几个常用的hexo命令 123456789101112hexo new "postName" ###新建文章hexo new page "pageName" ###新建页面hexo clean ###清理目录hexo generate ###生成静态页面至public目录hexo server ###开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy ###将.deploy目录部署到GitHub“###以上命令对应的简写”hexo nhexo cleanhexo ghexo shexo d 到这里我们本地hexo就安装完成了，接下来就是见证奇迹的时刻了，Git bash中切换到刚才的hexo目录执行下面命令： 12hexo ghexo s 然后用浏览器访问 http://localhost:4000/ ，此刻你就可以在本地预览到你的博客了，是不是很easy，很炫酷。 如何用hexo创建发表文章 1.1、打开Git bash里输入如下命令回车就可以创建一篇新文章 1hexo new "new post" 1.2、在hexo\source_posts下编辑对应的.md文件内容，hexo支持Markdown语法，语法很简单，markdown 中文文档，Windows 下推荐工具 markdownpad，下载地址：http://markdownpad.com/ 1.3、输入 12hexo g ###生成静态文件hexo s ###本地部署 1.4、浏览器打开 http://localhost:4000 进行预览 安装主题 hexo 3.0默认的主题是landscape，hexo也有很多的主题，这里有很多主题，我选择Next主题，上面有详细的设置。注意：hexo配置语法中标准的是： 冒号后跟个空格 2.1 Git bash 下cd 到hexo目录，输入： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 2.2 在hexo目录下找到_config.yml配置文件，找到 theme 字段，并将其值更改为 next 1theme: next 2.3 设置RSS在上面第一步中已经安装了Rss插件，只要在themes_config.yml配置文件中添加一行：1rss： 2.4 添加标签tags页面在hexo目录下输入 hexo new page 新建一个页面，命名为 tags，布局格式为page： 1hexo new page tags 内容如下，如果要关闭tags页面的评论可以设置comments为false,这样以后tags页面在每次执行hexo generate后自动更新： 12345title: 标签 date: 2017-01-07 00:00:00 type: "tags"comments: false--- 2.5 添加分类页面在hexo目录下输入 hexo new page 新建一个页面，命名为 categories，布局格式为page： 12345title: 分类date: 2017-01-07 00:00:00type: "categories"comments: false--- 2.6 添加404页面新建一个404.html文件，放到themes\next\source目录下，内容你自己定。 2.7 代码高亮在themes\next_config.yml 更改： 1highlight_theme: normal 2.8 hexo 中各个目录说明： 添加第三方服务3.1 多说评论登录多说官网，登录后点我要安装，然后填写站点相关信息，最主要的是duoshuo_shortname这个字段，设置后之后修改themes\next_config.yml文件，把duoshuo_shortname改成你的，如下所示： 1duoshuo_shortname: alexpdh 3.2 百度统计登录百度统计，转到获取代码截面，找到百度统计脚本id，然后把themes\next_config.yml文件下的baidu_analytics字段改成你的id，如下所示： 1baidu_analytics: xxxxxxxxx 3.3 站内搜索next主题集成了swiftype搜索，你需要到swiftype配置一个搜索引擎， 而后编辑 站点配置文件， 新增 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key: 1swiftype_key: xxxxxxxxx 其他第三方设置请参考：第三方服务集成 托管到GitHub和coding1、创建一个Github Pages Github Pages免费的静态站点，每个GitHub账户有300M的空间可以用来搭建自己的个人站点，其特点：免费托管、自带主题、支持自制页面等。创建 Github Pages 比较简单，只要你有一个github账号在创建一个仓库就行了，但是这个仓库是有规则的，其格式必须为： yourusername.github.io 。然后根据提示一直下一步即可，非常简单。命名格式中的yourusername 是你自己的github账号。 国内coding平台请参考Coding Pages 帮助 2、_config.yml配置打开hexo/_config.yml文件最下面的deploy设置为如下，记得账号替换成自己的： 12345deploy: type: git repo: github: git@github.com:alexpdh/alexpdh.github.io.git,master coding: git@git.coding.net:alexpdh/myblog.git,master 3、部署到git 输入如下命令就可以上传到两个平台部署了： 1hexo deploy 每次部署GitHub一般就是如下三步就完事（部署三步骤）： 12345hexo cleanhexo generatehexo deploy 附 _config.yml配置根目录下_config.yml 站点配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/#网站# Sitetitle: alexpdh's blog # 网站标题subtitle: # 网站副标题description: 你的时间在哪里，你的成就就在那里 # 网站描述author: alexpdh # 作者language: zh-Hans # 网站使用的语言timezone: Asia/Shanghai # 网站时区。Hexo 预设使用您电脑的时区。时区列表# 网址# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://alexpdh.com # 网址root: / # 网站根目录permalink: /blog/:year/:month/:day/:title/ # 文章的 永久链接 原格式 :year/:month/:day/:title/ 我放blog目录下permalink_defaults: # 永久链接中各部分的默认值# 目录# Directorysource_dir: source # 资源文件夹，这个文件夹用来存放内容。 sourcepublic_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件。 publictag_dir: tags # 标签文件夹 tagsarchive_dir: archives # 归档文件夹 archivescategory_dir: categories # 分类文件夹 categoriescode_dir: downloads/code # Include code 文件夹 downloads/codei18n_dir: :lang # 国际化（i18n）文件夹 :langskip_render: # 跳过指定文件的渲染，您可使用 glob 来配置路径。# 新建文章# Writingnew_post_name: :title.md # File name of new posts # 新文章的文件名称 :title.mddefault_layout: post # 预设布局 posttitlecase: false # Transform title into titlecase # 把标题转换为 title case falseexternal_link: true # Open external links in new tab # 在新标签中打开链接 truefilename_case: 0 # 把文件名称转换为 (1) 小写或 (2) 大写 0render_drafts: false # 显示草稿 falsepost_asset_folder: false # 启动 Asset 文件夹 false 设置为true时会默认在新建文章时会创建一个和.md文件同名的文件夹relative_link: false # 把链接改为与根目录的相对位址 falsefuture: true # 显示未来的文章 true# 代码块的设置highlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorized # 默认分类 uncategorizedcategory_map: # 分类别名tag_map: # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# 分页# Pagination## Set per_page to 0 to disable pagination per_page: 10 # 每页显示的文章量 (0 = 关闭分页功能) 10pagination_dir: page # 分页目录 page# 主题# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# 部署托管配置 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:alexpdh/alexpdh.github.io.git,master coding: git@git.coding.net:alexpdh/hexoblog.git,master 主题目录下 _config.yml 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico# Set default keywords (Use a comma to separate)keywords: "Hexo, NexT"# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss:# Specify the date when the site was setupsince: 2017# icon between year and author @Footerauthoricon: heart# Footer `powered-by` and `theme-info` copyrightcopyright: true# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remeber set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / categories: /categories archives: /archives tags: /tags about: /about #sitemap: /sitemap.xml #commonweal: /404.html# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Musescheme: Mist#scheme: Pisces# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal intalic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Linkssocial: GitHub: https://github.com/alexpdh weibo: http://weibo.com/alex1988520 zhihu: http://www.zhihu.com/people/alexpdh-1988 #Others:# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)#social: #LinkLabel: Link# Social Links Icons# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of the item and value is the name of FontAwsome icon. Key is case-senstive.# When an globe mask icon presenting up means that the item has no mapping icon.social_icons: enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter weibo: weibo zhihu: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /images/itdog.jpg# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. display: post #display: always #display: hide #display: remove# Blogrolls#links_title: Links#links_layout: block#links_layout: inline#links: #Title: http://example.com/ # title, chinese available links_title: 友情链接 # # links links: MacTalk: http://macshuo.com/ liaoxuefeng: http://www.liaoxuefeng.com/# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150# Use Lato fontuse_font_lato: true # Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg #description: ex. subscribe to my blog by scanning my public wechat account# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Swiftype Search API Keyswiftype_key: SELpQxw29CqCcMWn6235# Baidu Analytics IDbaidu_analytics: 9dc06432cf936b467fbc1592bb73673d# Duoshuo ShortNameduoshuo_shortname: alexpdh# Disqus#disqus_shortname:# Hypercomments#hypercomments_id:# Gentie productKey#gentie_productKey:# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share#jiathis:# Warning: JiaThis does not support https.#add_this_id:# Shareduoshuo_share: true# 多说热评文章 true 或者 falseduoshuo_hotartical: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0 #admin_nickname: Author# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer:# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Canvas-nestcanvas_nest: false# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.0 参考文献HEXO中文文档http://www.ezlippi.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客搭建完成，庆祝！]]></title>
      <url>%2F2017%2F01%2F07%2Fmy-first-blog%2F</url>
      <content type="text"><![CDATA[花了两天，终于把博客搭起来了。欢迎蹂躏！博客地址：http://alexpdh.com，欢迎访问 ！]]></content>
    </entry>

    
  
  
</search>
